// Approvals Page JavaScript with Confluence REST API Integration

// Include required libraries (add these script tags to your Confluence page)
// <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

// Configuration
const CONFIG = {
    confluence: {
        domain: 'https://www.myconfluence.net',  // Update with actual domain
        pageId: '123345346',
        api: {
            currentUser: '/rest/api/user/current',
            attachment: '/rest/api/content/{pageId}/child/attachment'
        }
    },
    files: {
        userDatabase: 'userdatabase.xlsx',
        mainTaskDatabase: 'maintaskdatabase.xlsx',
        taskMapping: 'taskmapping.xlsx',
        approvals: 'approvals.xlsx',
        notifications: 'notifications.xlsx',
        auditLog: 'audit_log.xlsx'
    },
    maxRowsPerPage: 50
};

// API Helper Functions (same as Page 1)
const API = {
    getCurrentUser: async function() {
        try {
            const response = await fetch(CONFIG.confluence.domain + CONFIG.confluence.api.currentUser, {
                credentials: 'same-origin'
            });
            if (!response.ok) {
                console.warn('User API returned:', response.status);
                return null;
            }
            const userData = await response.json();
            const normalizedUser = {
                displayName: userData.displayName || userData.fullName || userData.name || 'Unknown',
                key: userData.key || userData.username || userData.accountId || userData.name || userData.userName,
                email: userData.emailAddress || userData.email,
                ...userData
            };
            return normalizedUser;
        } catch (error) {
            console.warn('Error fetching current user:', error);
            return null;
        }
    },
    
    getAttachments: async function() {
        try {
            const url = CONFIG.confluence.domain +
                       CONFIG.confluence.api.attachment.replace('{pageId}', CONFIG.confluence.pageId);
            const response = await fetch(url, {
                credentials: 'same-origin'
            });
            if (!response.ok) throw new Error('Failed to fetch attachments');
            const data = await response.json();
            return data.results || [];
        } catch (error) {
            console.error('Error fetching attachments:', error);
            return [];
        }
    },
    
    downloadAttachment: async function(attachmentUrl) {
        try {
            const url = attachmentUrl.startsWith('http') ? attachmentUrl : CONFIG.confluence.domain + attachmentUrl;
            const response = await fetch(url, {
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                }
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            return arrayBuffer;
        } catch (error) {
            console.error('Error downloading attachment:', error);
            return null;
        }
    },
    
    uploadAttachment: async function(filename, blob) {
        try {
            const attachments = await this.getAttachments();
            const existingAttachment = attachments.find(att => att.title === filename);
            
            if (!existingAttachment) {
                throw new Error(`Attachment ${filename} not found`);
            }
            
            const formData = new FormData();
            formData.append('file', blob, filename);
            formData.append('minorEdit', 'true');
            formData.append('comment', 'Updated by Approval System');
            
            // Try multiple upload methods
            let url, response;
            
            // Method 1: Update existing attachment
            try {
                url = `${CONFIG.confluence.domain}/rest/api/content/${existingAttachment.id}/child/attachment/${existingAttachment.id}/data`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 1 failed, trying method 2');
            }
            
            // Method 2: Create new version
            try {
                url = `${CONFIG.confluence.domain}/rest/api/content/${CONFIG.confluence.pageId}/child/attachment`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 2 failed');
            }
            
            throw new Error('Failed to upload attachment');
            
        } catch (error) {
            console.error('Error uploading attachment:', error);
            throw error;
        }
    }
};

// Global variables  - initialize all as empty
let currentUser = null;
let allUsers = [];
let approvalRequests = [];
let filteredRequests = [];
let taskMapping = [];
let currentPage = 1;
let attachments = {};
let selectedRequests = new Set();
let sortColumn = 'Timestamp';
let sortDirection = 'desc';
let currentModalRequest = null;
let currentRejectRequest = null;

// Initialize the application
async function initializeApp() {
    showLoading(true);
    try {
        // Get current user from Confluence
        const confluenceUser = await API.getCurrentUser();
        if (!confluenceUser) {
            showToast('Could not get current user. Please ensure you are logged into Confluence.', 'error');
            return;
        }
        
        currentUser = {
            username: confluenceUser.key,
            displayName: confluenceUser.displayName,
            email: confluenceUser.email
        };
        
        // Load all attachments first
        await loadAttachments();
        
        // Load user data and check permissions
        const hasAccess = await checkUserAccess();
        if (!hasAccess) {
            showNoAccess();
            return;
        }
        
        // Load all necessary data
        await loadApprovalRequests();
        await loadTaskMapping();
        
        // Initialize UI
        initializeUI();
        
        // Apply initial filter (pending only by default)
        filterApprovals();
        updateStatistics();
        
    } catch (error) {
        console.error('Initialization error:', error);
        showToast('Failed to initialize application. Please refresh the page.', 'error');
    } finally {
        showLoading(false);
    }
}

// Load all attachments
async function loadAttachments() {
    const attachmentList = await API.getAttachments();
    attachmentList.forEach(att => {
        attachments[att.title] = att._links.download || att._links.webui;
    });
}

// Fetch and parse Excel file
async function fetchExcelData(filename) {
    try {
        const downloadUrl = attachments[filename];
        if (!downloadUrl) {
            throw new Error(`Attachment ${filename} not found`);
        }
        
        const arrayBuffer = await API.downloadAttachment(downloadUrl);
        if (!arrayBuffer) {
            throw new Error(`Failed to download ${filename}`);
        }
        
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        return workbook;
        
    } catch (error) {
        console.error(`Error fetching ${filename}:`, error);
        throw error;
    }
}

// Check user access (must be manager or admin)
async function checkUserAccess() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.userDatabase);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        allUsers = XLSX.utils.sheet_to_json(worksheet);
        
        const userData = allUsers.find(u => u.username === currentUser.username);
        if (!userData) {
            // Fallback for testing
            userData = allUsers.find(u => u.username === 'BD12345' || u.username === 'CQ12356');
        }
        
        if (!userData) {
            return false;
        }
        
        currentUser = { ...currentUser, ...userData };
        
        // Check if user has manager or admin role
        return userData.role === 'manager' || userData.role === 'admin';
        
    } catch (error) {
        console.error('Failed to check user access:', error);
        return false;
    }
}

// Load approval requests
async function loadApprovalRequests() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.approvals);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const allApprovals = XLSX.utils.sheet_to_json(worksheet);
        
        // Clear existing data
        approvalRequests = [];
        
        // Filter based on user role
        let relevantApprovals = [];
        if (currentUser.role === 'admin') {
            // Admin sees all requests
            relevantApprovals = allApprovals;
        } else if (currentUser.role === 'manager') {
            // Manager sees only requests from their team
            const teamMembers = allUsers.filter(u => u.team === currentUser.team);
            const teamUsernames = teamMembers.map(u => u.username);
            relevantApprovals = allApprovals.filter(req => teamUsernames.includes(req.Username));
        }
        
        // Add team information and ensure unique entries
        const processedIds = new Set();
        relevantApprovals.forEach(req => {
            // Create a unique key for each request
            const uniqueKey = `${req['Request ID']}_${req.Item_ID}_${req.Username}`;
            
            if (!processedIds.has(uniqueKey)) {
                processedIds.add(uniqueKey);
                const user = allUsers.find(u => u.username === req.Username);
                approvalRequests.push({
                    ...req,
                    Team: user ? user.team : 'Unknown',
                    UserName: user ? user.name : req.Username,
                    Status: req.Status || 'Pending'
                });
            }
        });
        
        console.log('Loaded approval requests:', approvalRequests.length);
        
    } catch (error) {
        console.error('Failed to load approval requests:', error);
        approvalRequests = [];
    }
}

// Load task mapping
async function loadTaskMapping() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.taskMapping);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        taskMapping = XLSX.utils.sheet_to_json(worksheet);
    } catch (error) {
        console.error('Failed to load task mapping:', error);
    }
}

// Initialize UI
function initializeUI() {
    setupFilters();
    updatePendingCount();
    
    // Set initial filter to pending only
    document.getElementById('statusFilter').value = 'pending';
    
    // Clear any existing filtered data
    filteredRequests = [];
}

// Setup filter dropdowns
function setupFilters() {
    // Team filter
    const teams = [...new Set(approvalRequests.map(r => r.Team))].filter(Boolean);
    const teamFilter = document.getElementById('teamFilter');
    teams.forEach(team => {
        const option = document.createElement('option');
        option.value = team;
        option.textContent = team;
        teamFilter.appendChild(option);
    });
    
    // Category filter
    const categories = [...new Set(approvalRequests.map(r => r.Category))].filter(Boolean);
    const categoryFilter = document.getElementById('categoryFilter');
    categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categoryFilter.appendChild(option);
    });
}

// Filter approvals based on search and filters
function filterApprovals() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const statusFilter = document.getElementById('statusFilter').value;
    const teamFilter = document.getElementById('teamFilter').value;
    const categoryFilter = document.getElementById('categoryFilter').value;
    
    // Create a new filtered array - don't modify the original
    filteredRequests = [];
    
    approvalRequests.forEach(req => {
        const matchesSearch = !searchTerm || 
            req.Username.toLowerCase().includes(searchTerm) ||
            req.UserName.toLowerCase().includes(searchTerm) ||
            (req.Task_Name && req.Task_Name.toLowerCase().includes(searchTerm)) ||
            (req['Request ID'] && req['Request ID'].toString().includes(searchTerm));
        
        let matchesStatus = false;
        if (statusFilter === 'all') {
            matchesStatus = true;
        } else if (statusFilter === 'pending') {
            matchesStatus = !req.Status || req.Status === 'Pending' || req.Status === 'pending';
        } else if (statusFilter === 'approved') {
            matchesStatus = req.Status === 'Approved' || req.Status === 'approved';
        } else if (statusFilter === 'rejected') {
            matchesStatus = req.Status === 'Rejected' || req.Status === 'rejected';
        }
        
        const matchesTeam = teamFilter === 'all' || req.Team === teamFilter;
        const matchesCategory = !categoryFilter || req.Category === categoryFilter;
        
        if (matchesSearch && matchesStatus && matchesTeam && matchesCategory) {
            filteredRequests.push(req);
        }
    });
    
    // Reset selection when filters change
    selectedRequests.clear();
    document.getElementById('selectAll').checked = false;
    updateSelectionUI();
    
    // Reset to first page when filters change
    currentPage = 1;
    renderTable();
}

// Render the approvals table
function renderTable() {
    const tbody = document.getElementById('approvalsTableBody');
    const emptyState = document.getElementById('emptyState');
    
    tbody.innerHTML = '';
    
    // Reset select all checkbox
    document.getElementById('selectAll').checked = false;
    
    // Make sure we're working with the filtered data, not the full dataset
    if (!filteredRequests || filteredRequests.length === 0) {
        document.getElementById('approvalsTable').style.display = 'none';
        emptyState.style.display = 'flex';
        updatePaginationInfo(0, 0, 0);
        return;
    }
    
    document.getElementById('approvalsTable').style.display = 'table';
    emptyState.style.display = 'none';
    
    // Create a deep copy of filtered requests to sort
    let dataToSort = JSON.parse(JSON.stringify(filteredRequests));
    
    // Sort the copied filtered requests
    dataToSort.sort((a, b) => {
        let aVal = a[sortColumn];
        let bVal = b[sortColumn];
        
        // Handle different column types
        if (sortColumn === 'Request ID') {
            aVal = parseInt(aVal) || 0;
            bVal = parseInt(bVal) || 0;
        } else if (sortColumn === 'Timestamp') {
            aVal = aVal ? new Date(aVal).getTime() : 0;
            bVal = bVal ? new Date(bVal).getTime() : 0;
        } else if (sortColumn === 'Status') {
            // Normalize status values for consistent sorting
            aVal = (aVal || 'Pending').toString().toLowerCase();
            bVal = (bVal || 'Pending').toString().toLowerCase();
        } else {
            aVal = (aVal || '').toString().toLowerCase();
            bVal = (bVal || '').toString().toLowerCase();
        }
        
        if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
        if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
        return 0;
    });
    
    // Paginate
    const startIndex = (currentPage - 1) * CONFIG.maxRowsPerPage;
    const endIndex = Math.min(startIndex + CONFIG.maxRowsPerPage, dataToSort.length);
    const pageData = dataToSort.slice(startIndex, endIndex);
    
    // Render rows
    pageData.forEach(req => {
        const row = document.createElement('tr');
        
        // Collect all market changes
        const changes = [];
        const markets = Object.keys(req).filter(key => 
            !['Request ID', 'Username', 'Item_ID', 'Category', 'Task_Group', 
              'Task_Name', 'Status', 'Timestamp', 'Team', 'UserName', 'ProcessedBy',
              'ProcessedAt', 'RejectionReason'].includes(key)
        );
        
        markets.forEach(market => {
            if (req[market]) {
                changes.push({
                    market: market,
                    value: req[market]
                });
            }
        });
        
        const isPending = !req.Status || req.Status === 'Pending';
        
        row.innerHTML = `
            <td>
                <input type="checkbox" 
                       data-request-id="${req['Request ID']}"
                       onchange="toggleSelection('${req['Request ID']}')"
                       ${!isPending ? 'disabled' : ''}>
            </td>
            <td><strong>#${req['Request ID'] || 'N/A'}</strong></td>
            <td>
                <div><strong>${req.UserName || req.Username}</strong></div>
                <div style="font-size: 11px; color: var(--gray);">${req.Username}</div>
            </td>
            <td>${req.Team || 'N/A'}</td>
            <td>${req.Task_Name || 'N/A'}</td>
            <td>${req.Category || 'N/A'}</td>
            <td>
                <div class="changes-list">
                    ${changes.map(c => `
                        <div class="change-item">
                            <span class="market-tag">${c.market}</span>
                            <span class="change-arrow">â†’</span>
                            <span class="change-to">${c.value.toUpperCase()}</span>
                        </div>
                    `).join('')}
                </div>
            </td>
            <td>${formatDate(req.Timestamp)}</td>
            <td>
                <span class="status-badge ${(req.Status || 'pending').toLowerCase()}">
                    ${req.Status || 'Pending'}
                </span>
            </td>
            <td>
                <div class="action-buttons">
                    ${isPending ? `
                        <button class="action-btn approve" onclick="approveRequest('${req['Request ID']}')">
                            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                            </svg>
                            Approve
                        </button>
                        <button class="action-btn reject" onclick="rejectRequest('${req['Request ID']}')">
                            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                            Reject
                        </button>
                    ` : ''}
                    <button class="action-btn view" onclick="viewDetails('${req['Request ID']}')">
                        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                        </svg>
                        View
                    </button>
                </div>
            </td>
        `;
        
        tbody.appendChild(row);
    });
    
    updatePagination();
    updatePaginationInfo(startIndex + 1, endIndex, dataToSort.length);
}

// Approve request
async function approveRequest(requestId) {
    // Convert to string for comparison
    requestId = requestId.toString();
    const request = approvalRequests.find(r => r['Request ID'].toString() === requestId);
    if (!request) {
        console.error('Request not found:', requestId);
        return;
    }
    
    showLoading(true);
    try {
        // Update maintaskdatabase.xlsx with approved changes
        await updateUserSkills(request, true);
        
        // Update approval status
        await updateApprovalStatus(requestId, 'Approved');
        
        // Create notification
        await createNotification(request.Username, requestId, 'Approved');
        
        showToast(`Request #${requestId} has been approved`, 'success');
        
        // Hard refresh the page
        setTimeout(() => {
            window.location.reload();
        }, 1000);
        
    } catch (error) {
        console.error('Failed to approve request:', error);
        showToast('Failed to approve request. Please try again.', 'error');
        showLoading(false);
    }
}

// Reject request
function rejectRequest(requestId) {
    // Convert to string for consistent comparison
    currentRejectRequest = requestId.toString();
    document.getElementById('rejectionReason').value = '';
    document.getElementById('rejectModal').classList.add('active');
}

// Confirm rejection
async function confirmReject() {
    const requestId = currentRejectRequest;  // Already converted to string
    const reason = document.getElementById('rejectionReason').value;
    
    if (!reason.trim()) {
        showToast('Please provide a rejection reason', 'warning');
        return;
    }
    
    const request = approvalRequests.find(r => r['Request ID'].toString() === requestId);
    if (!request) {
        console.error('Request not found:', requestId);
        return;
    }
    
    closeRejectModal();
    showLoading(true);
    
    try {
        // Update approval status
        await updateApprovalStatus(requestId, 'Rejected', reason);
        
        // Create notification
        await createNotification(request.Username, requestId, 'Rejected', reason);
        
        showToast(`Request #${requestId} has been rejected`, 'info');
        
        // Hard refresh the page
        setTimeout(() => {
            window.location.reload();
        }, 1000);
        
    } catch (error) {
        console.error('Failed to reject request:', error);
        showToast('Failed to reject request. Please try again.', 'error');
        showLoading(false);
    }
}

// Update user skills in maintaskdatabase.xlsx
async function updateUserSkills(request, approved) {
    if (!approved) return;
    
    try {
        const workbook = await fetchExcelData(CONFIG.files.mainTaskDatabase);
        
        // Check if user sheet exists, if not create it
        if (!workbook.SheetNames.includes(request.Username)) {
            console.log(`Creating new sheet for user ${request.Username}`);
            workbook.SheetNames.push(request.Username);
            workbook.Sheets[request.Username] = XLSX.utils.aoa_to_sheet([[]]);
        }
        
        const userSheet = workbook.Sheets[request.Username];
        const userSkills = XLSX.utils.sheet_to_json(userSheet);
        
        // Update the specific task
        const skillIndex = userSkills.findIndex(s => s.Item_ID == request.Item_ID);
        if (skillIndex !== -1) {
            // Update all market values from the request
            const markets = Object.keys(request).filter(key => 
                !['Request ID', 'Username', 'Item_ID', 'Category', 'Task_Group', 
                  'Task_Name', 'Status', 'Timestamp', 'Team', 'UserName', 'ProcessedBy',
                  'ProcessedAt', 'RejectionReason'].includes(key)
            );
            
            markets.forEach(market => {
                if (request[market]) {
                    userSkills[skillIndex][market] = request[market];
                }
            });
        } else {
            console.log(`Task ${request.Item_ID} not found for user ${request.Username}, skipping update`);
        }
        
        // Update worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(userSkills);
        workbook.Sheets[request.Username] = newWorksheet;
        
        // Save file
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.mainTaskDatabase, blob);
        
    } catch (error) {
        console.error('Failed to update user skills:', error);
        throw error;
    }
}

// Update approval status
async function updateApprovalStatus(requestId, status, reason = '') {
    try {
        const workbook = await fetchExcelData(CONFIG.files.approvals);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const approvals = XLSX.utils.sheet_to_json(worksheet);
        
        // Convert requestId to string for comparison
        requestId = requestId.toString();
        
        // Update status for all entries with this request ID
        approvals.forEach(approval => {
            if (approval['Request ID'] && approval['Request ID'].toString() === requestId) {
                approval.Status = status;
                approval.ProcessedBy = currentUser.username;
                approval.ProcessedAt = new Date().toISOString();
                if (reason) {
                    approval.RejectionReason = reason;
                }
            }
        });
        
        // Update worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(approvals);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Save file
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.approvals, blob);
        
    } catch (error) {
        console.error('Failed to update approval status:', error);
        throw error;
    }
}

// Create notification
async function createNotification(username, requestId, status, reason = '') {
    try {
        const workbook = await fetchExcelData(CONFIG.files.notifications);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const notifications = XLSX.utils.sheet_to_json(worksheet);
        
        // Add new notification
        notifications.push({
            'Request ID': requestId,
            'Username': username,
            'Status': status,
            'Request Type': 'Skill Update',
            'Timestamp': new Date().toISOString(),
            'ProcessedBy': currentUser.username,
            'Reason': reason
        });
        
        // Update worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(notifications);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Save file
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.notifications, blob);
        
    } catch (error) {
        console.error('Failed to create notification:', error);
        throw error;
    }
}

// Bulk approve
async function bulkApprove() {
    if (selectedRequests.size === 0) return;
    
    const confirmed = confirm(`Are you sure you want to approve ${selectedRequests.size} requests?`);
    if (!confirmed) return;
    
    showLoading(true);
    let successCount = 0;
    let failCount = 0;
    
    for (const requestId of selectedRequests) {
        try {
            const request = approvalRequests.find(r => r['Request ID'].toString() === requestId);
            if (request) {
                await updateUserSkills(request, true);
                await updateApprovalStatus(request['Request ID'], 'Approved');
                await createNotification(request.Username, request['Request ID'], 'Approved');
                successCount++;
            }
        } catch (error) {
            console.error(`Failed to approve request ${requestId}:`, error);
            failCount++;
        }
    }
    
    if (failCount > 0) {
        showToast(`Approved ${successCount} requests, ${failCount} failed`, 'warning');
    } else {
        showToast(`Successfully approved ${successCount} requests`, 'success');
    }
    
    // Hard refresh after bulk approve
    setTimeout(() => {
        window.location.reload();
    }, 1500);
}

// View details modal
function viewDetails(requestId) {
    // Convert to string for consistent comparison
    requestId = requestId.toString();
    const request = approvalRequests.find(r => r['Request ID'].toString() === requestId);
    if (!request) {
        console.error('Request not found:', requestId);
        return;
    }
    
    currentModalRequest = request;
    
    const content = document.getElementById('modalDetailsContent');
    
    // Collect changes
    const changes = [];
    const markets = Object.keys(request).filter(key => 
        !['Request ID', 'Username', 'Item_ID', 'Category', 'Task_Group', 
          'Task_Name', 'Status', 'Timestamp', 'Team', 'UserName', 'ProcessedBy', 
          'ProcessedAt', 'RejectionReason'].includes(key)
    );
    
    markets.forEach(market => {
        if (request[market]) {
            changes.push({
                market: market,
                newValue: request[market]
            });
        }
    });
    
    content.innerHTML = `
        <div class="detail-section">
            <div class="detail-section-title">Request Information</div>
            <div class="detail-row">
                <span class="detail-label">Request ID:</span>
                <span class="detail-value">#${request['Request ID']}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Submitted By:</span>
                <span class="detail-value">${request.UserName} (${request.Username})</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Team:</span>
                <span class="detail-value">${request.Team}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Submitted On:</span>
                <span class="detail-value">${formatDate(request.Timestamp)}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Status:</span>
                <span class="detail-value">
                    <span class="status-badge ${(request.Status || 'pending').toLowerCase()}">
                        ${request.Status || 'Pending'}
                    </span>
                </span>
            </div>
            ${request.ProcessedBy ? `
                <div class="detail-row">
                    <span class="detail-label">Processed By:</span>
                    <span class="detail-value">${request.ProcessedBy}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Processed On:</span>
                    <span class="detail-value">${formatDate(request.ProcessedAt)}</span>
                </div>
            ` : ''}
            ${request.RejectionReason ? `
                <div class="detail-row">
                    <span class="detail-label">Rejection Reason:</span>
                    <span class="detail-value">${request.RejectionReason}</span>
                </div>
            ` : ''}
        </div>
        
        <div class="detail-section">
            <div class="detail-section-title">Task Details</div>
            <div class="detail-row">
                <span class="detail-label">Task ID:</span>
                <span class="detail-value">${request.Item_ID}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Task Name:</span>
                <span class="detail-value">${request.Task_Name}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Category:</span>
                <span class="detail-value">${request.Category}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Task Group:</span>
                <span class="detail-value">${request.Task_Group}</span>
            </div>
        </div>
        
        <div class="detail-section">
            <div class="detail-section-title">Requested Changes</div>
            <table class="changes-table">
                <thead>
                    <tr>
                        <th>Market</th>
                        <th>New Value</th>
                    </tr>
                </thead>
                <tbody>
                    ${changes.map(c => `
                        <tr>
                            <td><span class="market-tag">${c.market}</span></td>
                            <td><span class="change-to">${c.newValue.toUpperCase()}</span></td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>
    `;
    
    // Update modal footer buttons based on status
    const modalFooter = document.querySelector('#detailsModal .modal-footer');
    const isPending = !request.Status || request.Status === 'Pending';
    
    if (isPending) {
        modalFooter.querySelector('.btn-success').style.display = 'flex';
        modalFooter.querySelector('.btn-danger').style.display = 'flex';
    } else {
        modalFooter.querySelector('.btn-success').style.display = 'none';
        modalFooter.querySelector('.btn-danger').style.display = 'none';
    }
    
    document.getElementById('detailsModal').classList.add('active');
}
    
    // Update modal footer buttons based on status
    const modalFooter = document.querySelector('#detailsModal .modal-footer');
    const isPending = !request.Status || request.Status === 'Pending';
    
    if (isPending) {
        modalFooter.querySelector('.btn-success').style.display = 'flex';
        modalFooter.querySelector('.btn-danger').style.display = 'flex';
    } else {
        modalFooter.querySelector('.btn-success').style.display = 'none';
        modalFooter.querySelector('.btn-danger').style.display = 'none';
    }
    
    document.getElementById('detailsModal').classList.add('active');
}

// Modal actions
function approveFromModal() {
    if (currentModalRequest) {
        closeDetailsModal();
        approveRequest(currentModalRequest['Request ID']);
    }
}

function rejectFromModal() {
    if (currentModalRequest) {
        closeDetailsModal();
        rejectRequest(currentModalRequest['Request ID']);
    }
}

// Selection handling
function toggleSelection(requestId) {
    // Convert to string for consistent handling
    requestId = requestId.toString();
    const checkbox = document.querySelector(`input[data-request-id="${requestId}"]`);
    if (!checkbox) return;
    
    if (checkbox.checked) {
        selectedRequests.add(requestId);
    } else {
        selectedRequests.delete(requestId);
    }
    updateSelectionUI();
}

function toggleSelectAll() {
    const selectAll = document.getElementById('selectAll');
    const checkboxes = document.querySelectorAll('#approvalsTableBody input[type="checkbox"]:not(:disabled)');
    
    if (selectAll.checked) {
        checkboxes.forEach(cb => {
            cb.checked = true;
            const requestId = parseInt(cb.dataset.requestId);
            selectedRequests.add(requestId);
        });
    } else {
        checkboxes.forEach(cb => {
            cb.checked = false;
        });
        selectedRequests.clear();
    }
    
    updateSelectionUI();
}

function updateSelectionUI() {
    document.getElementById('selectedCount').textContent = selectedRequests.size;
    document.getElementById('bulkApproveBtn').disabled = selectedRequests.size === 0;
}

// Sort table
function sortTable(column) {
    // Update sort direction
    if (sortColumn === column) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        sortColumn = column;
        sortDirection = 'asc';
    }
    
    // Update sort indicators
    document.querySelectorAll('.approvals-table th').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
    });
    
    // Find the correct header and add sort indicator
    let headerText = column;
    if (column === 'Request ID') headerText = 'Request ID';
    else if (column === 'Username') headerText = 'User';
    else if (column === 'Team') headerText = 'Team';
    else if (column === 'Task_Name') headerText = 'Task Name';
    else if (column === 'Category') headerText = 'Category';
    else if (column === 'Timestamp') headerText = 'Submitted';
    else if (column === 'Status') headerText = 'Status';
    
    const headers = Array.from(document.querySelectorAll('.approvals-table th'));
    const th = headers.find(h => h.textContent.includes(headerText));
    
    if (th) {
        th.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    
    // Just re-render the table with the current filtered data
    renderTable();
}

// Update statistics
function updateStatistics() {
    const today = new Date().toDateString();
    
    const pending = approvalRequests.filter(r => !r.Status || r.Status === 'Pending').length;
    const approvedToday = approvalRequests.filter(r => 
        r.Status === 'Approved' && 
        r.ProcessedAt && 
        new Date(r.ProcessedAt).toDateString() === today
    ).length;
    const rejectedToday = approvalRequests.filter(r => 
        r.Status === 'Rejected' && 
        r.ProcessedAt && 
        new Date(r.ProcessedAt).toDateString() === today
    ).length;
    const totalProcessed = approvalRequests.filter(r => 
        r.Status === 'Approved' || r.Status === 'Rejected'
    ).length;
    
    document.getElementById('pendingRequests').textContent = pending;
    document.getElementById('approvedToday').textContent = approvedToday;
    document.getElementById('rejectedToday').textContent = rejectedToday;
    document.getElementById('totalProcessed').textContent = totalProcessed;
    
    updatePendingCount();
}

function updatePendingCount() {
    const pending = approvalRequests.filter(r => !r.Status || r.Status === 'Pending').length;
    document.getElementById('pendingCount').textContent = pending;
}

// Pagination
function updatePagination() {
    const totalPages = Math.ceil(filteredRequests.length / CONFIG.maxRowsPerPage);
    const paginationControls = document.getElementById('paginationControls');
    paginationControls.innerHTML = '';
    
    if (totalPages <= 1) return;
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.className = 'page-btn';
    prevBtn.textContent = 'Previous';
    prevBtn.disabled = currentPage === 1;
    prevBtn.onclick = () => {
        if (currentPage > 1) {
            currentPage--;
            renderTable();
        }
    };
    paginationControls.appendChild(prevBtn);
    
    // Page numbers
    let startPage = Math.max(1, currentPage - 2);
    let endPage = Math.min(totalPages, startPage + 4);
    
    if (endPage - startPage < 4) {
        startPage = Math.max(1, endPage - 4);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageBtn = document.createElement('button');
        pageBtn.className = 'page-btn' + (i === currentPage ? ' active' : '');
        pageBtn.textContent = i;
        pageBtn.onclick = () => {
            currentPage = i;
            renderTable();
        };
        paginationControls.appendChild(pageBtn);
    }
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.className = 'page-btn';
    nextBtn.textContent = 'Next';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.onclick = () => {
        if (currentPage < totalPages) {
            currentPage++;
            renderTable();
        }
    };
    paginationControls.appendChild(nextBtn);
}

function updatePaginationInfo(from, to, total) {
    document.getElementById('showingFrom').textContent = from;
    document.getElementById('showingTo').textContent = to;
    document.getElementById('totalRecords').textContent = total;
}

// Export functionality
function exportApprovals() {
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(filteredRequests);
    XLSX.utils.book_append_sheet(wb, ws, 'Approval Requests');
    XLSX.writeFile(wb, `approval_requests_${new Date().getTime()}.xlsx`);
    showToast('Data exported successfully', 'success');
}

// Refresh data
function refreshApprovals() {
    showToast('Refreshing data...', 'info');
    setTimeout(() => {
        window.location.reload();
    }, 500);
}

// Modal functions
function closeDetailsModal() {
    document.getElementById('detailsModal').classList.remove('active');
    currentModalRequest = null;
}

function closeRejectModal() {
    document.getElementById('rejectModal').classList.remove('active');
    currentRejectRequest = null;
}

// Utility functions
function formatDate(dateString) {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (e) {
        return dateString;
    }
}

function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.toggle('active', show);
    }
}

function showNoAccess() {
    document.getElementById('approvalsPage').style.display = 'none';
    document.getElementById('noAccessMessage').style.display = 'flex';
}

// Toast notification system (same as Page 1)
function showToast(message, type = 'info', title = '') {
    const toastContainer = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    const icons = {
        success: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>',
        error: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>',
        warning: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>',
        info: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>'
    };
    
    const defaultTitles = {
        success: 'Success',
        error: 'Error',
        warning: 'Warning',
        info: 'Information'
    };
    
    const toastTitle = title || defaultTitles[type];
    
    toast.innerHTML = `
        ${icons[type]}
        <div class="toast-content">
            <div class="toast-title">${toastTitle}</div>
            <div class="toast-message">${message}</div>
        </div>
        <button class="toast-close" onclick="removeToast(this.parentElement)">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>
    `;
    
    toastContainer.appendChild(toast);
    
    setTimeout(() => {
        removeToast(toast);
    }, 5000);
}

function removeToast(toast) {
    if (!toast || toast.classList.contains('removing')) return;
    
    toast.classList.add('removing');
    setTimeout(() => {
        if (toast.parentElement) {
            toast.remove();
        }
    }, 300);
}

// Track if already initialized
let isInitialized = false;

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        if (!isInitialized) {
            isInitialized = true;
            initializeApp();
        }
    });
} else {
    if (!isInitialized) {
        isInitialized = true;
        initializeApp();
    }
}