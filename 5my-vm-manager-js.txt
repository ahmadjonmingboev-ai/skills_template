// My VM Manager JavaScript with Confluence REST API Integration

// Include required libraries (add these script tags to your Confluence page)
// <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
// <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

// Configuration
const CONFIG = {
    confluence: {
        domain: 'https://www.myconfluence.net',  // Update with actual domain
        pageId: '123345346',
        api: {
            currentUser: '/rest/api/user/current',
            attachment: '/rest/api/content/{pageId}/child/attachment'
        }
    },
    files: {
        userDatabase: 'userdatabase.xlsx',
        mainTaskDatabase: 'maintaskdatabase.xlsx',
        taskMapping: 'taskmapping.xlsx',
        approvals: 'approvals.xlsx',
        notifications: 'notifications.xlsx',
        auditLog: 'audit_log.xlsx'
    },
    maxRowsPerPage: 50
};

// API Helper Functions
const API = {
    // Get current user
    getCurrentUser: async function() {
        try {
            const response = await fetch(CONFIG.confluence.domain + CONFIG.confluence.api.currentUser, {
                credentials: 'same-origin'
            });
            if (!response.ok) {
                console.warn('User API returned:', response.status);
                return null;
            }
            const userData = await response.json();
           
            // Log the full response for debugging
            console.log('Confluence user API response:', userData);
           
            // Different Confluence versions return different structures
            // Try to normalize the response
            const normalizedUser = {
                displayName: userData.displayName || userData.fullName || userData.name || 'Unknown',
                // Try different possible fields for the username/ID that matches SOEID
                key: userData.key || userData.username || userData.accountId || userData.name || userData.userName,
                email: userData.emailAddress || userData.email,
                ...userData // Keep all original fields
            };
           
            console.log('Normalized user data:', normalizedUser);
            return normalizedUser;
        } catch (error) {
            console.warn('Error fetching current user (this is normal if not logged in):', error);
            return null;
        }
    },
   
    // Get page attachments
    getAttachments: async function() {
        try {
            const url = CONFIG.confluence.domain +
                       CONFIG.confluence.api.attachment.replace('{pageId}', CONFIG.confluence.pageId);
            const response = await fetch(url, {
                credentials: 'same-origin'
            });
            if (!response.ok) throw new Error('Failed to fetch attachments');
            const data = await response.json();
            return data.results || [];
        } catch (error) {
            console.error('Error fetching attachments:', error);
            return [];
        }
    },
   
    // Download attachment
    downloadAttachment: async function(attachmentUrl) {
        try {
            // Fix URL construction
            const url = attachmentUrl.startsWith('http') ? attachmentUrl : CONFIG.confluence.domain + attachmentUrl;
           
            const response = await fetch(url, {
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                }
            });
           
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
           
            const arrayBuffer = await response.arrayBuffer();
            return arrayBuffer;
        } catch (error) {
            console.error('Error downloading attachment:', error);
            return null;
        }
    },
   
    // Upload attachment (for saving changes)
    uploadAttachment: async function(filename, blob) {
        try {
            // First, we need to get the current attachment to update it
            const attachments = await this.getAttachments();
            const existingAttachment = attachments.find(att => att.title === filename);
           
            if (!existingAttachment) {
                throw new Error(`Attachment ${filename} not found`);
            }
           
            console.log('Found existing attachment:', existingAttachment);
           
            const formData = new FormData();
            formData.append('file', blob, filename);
            formData.append('minorEdit', 'true');
            formData.append('comment', 'Updated by Skill Manager');
           
            // Try different API endpoints based on Confluence version
            let url, response;
           
            // Method 1: Update existing attachment using REST API v1
            try {
                url = `${CONFIG.confluence.domain}/rest/api/content/${existingAttachment.id}/child/attachment/${existingAttachment.id}/data`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
               
                if (response.ok) {
                    console.log('Upload successful using method 1');
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 1 failed, trying method 2');
            }
           
            // Method 2: Create new version of attachment
            try {
                url = `${CONFIG.confluence.domain}/rest/api/content/${CONFIG.confluence.pageId}/child/attachment`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
               
                if (response.ok) {
                    console.log('Upload successful using method 2');
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 2 failed, trying method 3');
            }
           
            // Method 3: Delete and re-upload
            try {
                // Delete old attachment
                const deleteUrl = `${CONFIG.confluence.domain}/rest/api/content/${existingAttachment.id}`;
                await fetch(deleteUrl, {
                    method: 'DELETE',
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
               
                // Upload new attachment
                url = `${CONFIG.confluence.domain}/rest/api/content/${CONFIG.confluence.pageId}/child/attachment`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
               
                if (response.ok) {
                    console.log('Upload successful using method 3 (delete and re-upload)');
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 3 failed');
            }
           
            // If all methods failed
            const errorText = await response.text();
            console.error('All upload methods failed. Last error:', errorText);
            throw new Error(`Failed to upload attachment: ${response.status} - ${errorText}`);
           
        } catch (error) {
            console.error('Error uploading attachment:', error);
            throw error; // Re-throw to handle in calling function
        }
    }
};

// Global variables
let currentUser = null;
let userData = null;
let userSkills = [];
let taskMapping = [];
let notifications = [];
let currentPage = 1;
let filteredData = [];
let marketChart = null;
let attachments = {};
let sortColumn = null;
let sortDirection = 'asc';

// Toast Notification System
function showToast(message, type = 'info', title = '') {
    const toastContainer = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    // Icons for different types
    const icons = {
        success: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>',
        error: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>',
        warning: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>',
        info: '<svg class="toast-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>'
    };
    
    // Default titles if not provided
    const defaultTitles = {
        success: 'Success',
        error: 'Error',
        warning: 'Warning',
        info: 'Information'
    };
    
    const toastTitle = title || defaultTitles[type];
    
    toast.innerHTML = `
        ${icons[type]}
        <div class="toast-content">
            <div class="toast-title">${toastTitle}</div>
            <div class="toast-message">${message}</div>
        </div>
        <button class="toast-close" onclick="removeToast(this.parentElement)">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>
    `;
    
    toastContainer.appendChild(toast);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        removeToast(toast);
    }, 5000);
}

function removeToast(toast) {
    if (!toast || toast.classList.contains('removing')) return;
    
    toast.classList.add('removing');
    setTimeout(() => {
        if (toast.parentElement) {
            toast.remove();
        }
    }, 300);
}

// Initialize the application
async function initializeApp() {
    showLoading(true);
    try {
        // Get current user from Confluence
        const confluenceUser = await API.getCurrentUser();
        if (!confluenceUser) {
            showToast('Could not get current user. Please ensure you are logged into Confluence.', 'error');
            return;
        }
        
        currentUser = {
            username: confluenceUser.key,  // This should match the username in Excel
            displayName: confluenceUser.displayName,
            email: confluenceUser.email
        };
        
        console.log('Current user:', currentUser);
        
        // Load all attachments first
        await loadAttachments();
        
        // Load all necessary data
        await loadUserData();
        await loadUserSkills();
        await loadTaskMapping();
        await loadNotifications();
        
        // Initialize UI components
        initializeUI();
        renderTable();
        updateStatistics();
        initializeChart();
        
    } catch (error) {
        console.error('Initialization error:', error);
        showToast('Failed to initialize application. Please refresh the page.', 'error');
    } finally {
        showLoading(false);
    }
}

// Load all attachments and store their download URLs
async function loadAttachments() {
    const attachmentList = await API.getAttachments();
    console.log('Found attachments:', attachmentList);
    
    attachmentList.forEach(att => {
        attachments[att.title] = att._links.download || att._links.webui;
    });
    
    console.log('Attachment URLs:', attachments);
}

// Fetch and parse Excel file
async function fetchExcelData(filename) {
    try {
        const downloadUrl = attachments[filename];
        if (!downloadUrl) {
            throw new Error(`Attachment ${filename} not found`);
        }
        
        console.log(`Fetching ${filename} from ${downloadUrl}`);
        const arrayBuffer = await API.downloadAttachment(downloadUrl);
        
        if (!arrayBuffer) {
            throw new Error(`Failed to download ${filename}`);
        }
        
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        return workbook;
        
    } catch (error) {
        console.error(`Error fetching ${filename}:`, error);
        throw error;
    }
}

// Load user data from Excel
async function loadUserData() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.userDatabase);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const users = XLSX.utils.sheet_to_json(worksheet);
        
        console.log('Users loaded:', users);
        
        // Find current user in database
        userData = users.find(u => u.username === currentUser.username);
        
        if (!userData) {
            // Try fallback - look for test user or first user
            console.warn(`User ${currentUser.username} not found in database, using fallback`);
            userData = users.find(u => u.username === 'AM28890') || users[0];
        }
        
        if (!userData) {
            throw new Error('User not found in database');
        }
        
        // Update user profile display
        document.getElementById('userName').textContent = userData.name;
        document.getElementById('userTeam').textContent = userData.team;
        document.getElementById('userRole').textContent = userData.role;
        document.getElementById('userTenure').textContent = userData.tenure;
        document.getElementById('userEmail').textContent = userData.email;
        
        // Update current user with database info
        currentUser = { ...currentUser, ...userData };
        
        console.log('User data loaded:', currentUser);
        
    } catch (error) {
        console.error('Failed to load user data:', error);
        throw error;
    }
}

// Load user skills from Excel
async function loadUserSkills() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.mainTaskDatabase);
        
        console.log('Available sheets:', workbook.SheetNames);
        
        // Check if user has a sheet
        const userSheet = currentUser.username;
        if (!workbook.SheetNames.includes(userSheet)) {
            console.warn(`No sheet found for ${userSheet}, checking alternatives`);
            // Try to find a sheet for the user
            const possibleSheet = workbook.SheetNames.find(name => 
                name.toLowerCase() === userSheet.toLowerCase()
            );
            
            if (!possibleSheet) {
                showToast('No skill data found for user', 'warning');
                userSkills = [];
                filteredData = [];
                return;
            }
            
            currentUser.username = possibleSheet;
        }
        
        const worksheet = workbook.Sheets[currentUser.username];
        userSkills = XLSX.utils.sheet_to_json(worksheet);
        filteredData = [...userSkills];
        
        console.log('User skills loaded:', userSkills.length, 'tasks');
        
    } catch (error) {
        console.error('Failed to load user skills:', error);
        throw error;
    }
}

// Load task mapping from Excel
async function loadTaskMapping() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.taskMapping);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        taskMapping = XLSX.utils.sheet_to_json(worksheet);
        
        console.log('Task mapping loaded:', taskMapping.length, 'mappings');
        
    } catch (error) {
        console.error('Failed to load task mapping:', error);
        throw error;
    }
}

// Load notifications from Excel
async function loadNotifications() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.notifications);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const allNotifications = XLSX.utils.sheet_to_json(worksheet);
        
        // Filter notifications for current user
        notifications = allNotifications.filter(n => n.Username === currentUser.username);
        
        console.log('Notifications loaded:', notifications.length, 'for user');
        
        // Update notification badge
        const badge = document.getElementById('notificationBadge');
        badge.textContent = notifications.length;
        badge.style.display = notifications.length > 0 ? 'block' : 'none';
        
    } catch (error) {
        console.error('Failed to load notifications:', error);
        // Non-critical, continue without notifications
        notifications = [];
    }
}

// Initialize UI components
function initializeUI() {
    // Setup search
    document.getElementById('searchInput').addEventListener('input', handleSearch);
    
    // Setup filters
    setupFilters();
    
    // Setup export button
    document.getElementById('exportBtn').addEventListener('click', exportData);
    
    // Setup modal buttons
    document.getElementById('editSkillsBtn').addEventListener('click', openEditModal);
    document.getElementById('notificationBtn').addEventListener('click', openNotificationsModal);
}

// Setup filter dropdowns
function setupFilters() {
    if (!userSkills || userSkills.length === 0) return;
    
    const categories = [...new Set(userSkills.map(s => s.Category))].filter(Boolean);
    const taskGroups = [...new Set(userSkills.map(s => s.Task_Group))].filter(Boolean);
    
    const categoryFilter = document.getElementById('categoryFilter');
    categoryFilter.innerHTML = '<option value="">All Categories</option>';
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat;
        categoryFilter.appendChild(option);
    });
    
    const taskGroupFilter = document.getElementById('taskGroupFilter');
    taskGroupFilter.innerHTML = '<option value="">All Task Groups</option>';
    taskGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group;
        option.textContent = group;
        taskGroupFilter.appendChild(option);
    });
    
    categoryFilter.addEventListener('change', applyFilters);
    taskGroupFilter.addEventListener('change', applyFilters);
}

// Handle search
function handleSearch(e) {
    const searchTerm = e.target.value.toLowerCase();
    applyFilters();
}

// Apply all filters
function applyFilters() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const categoryFilter = document.getElementById('categoryFilter').value;
    const taskGroupFilter = document.getElementById('taskGroupFilter').value;
    
    filteredData = userSkills.filter(skill => {
        const matchesSearch = !searchTerm || 
            (skill.Task_Name && skill.Task_Name.toLowerCase().includes(searchTerm));
        const matchesCategory = !categoryFilter || skill.Category === categoryFilter;
        const matchesTaskGroup = !taskGroupFilter || skill.Task_Group === taskGroupFilter;
        
        return matchesSearch && matchesCategory && matchesTaskGroup;
    });
    
    currentPage = 1;
    renderTable();
}

// Render the skills table
function renderTable() {
    const tableHeader = document.getElementById('tableHeader');
    const tableBody = document.getElementById('tableBody');
    
    // Clear existing content
    tableHeader.innerHTML = '';
    tableBody.innerHTML = '';
    
    if (!filteredData || filteredData.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="100%" style="text-align: center; padding: 40px;">No data found</td></tr>';
        updatePaginationInfo(0, 0, 0);
        return;
    }
    
    // Get markets from first row
    const markets = Object.keys(filteredData[0]).filter(key => 
        !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
    );
    
    // Create header (without Item ID)
    const headerRow = document.createElement('tr');
    
    // Add main column headers
    const categoryHeader = document.createElement('th');
    categoryHeader.onclick = () => sortTable('Category');
    categoryHeader.dataset.column = 'Category';
    categoryHeader.innerHTML = 'Category <span class="sort-indicator"></span>';
    headerRow.appendChild(categoryHeader);
    
    const taskGroupHeader = document.createElement('th');
    taskGroupHeader.onclick = () => sortTable('Task_Group');
    taskGroupHeader.dataset.column = 'Task_Group';
    taskGroupHeader.innerHTML = 'Task Group <span class="sort-indicator"></span>';
    headerRow.appendChild(taskGroupHeader);
    
    const taskNameHeader = document.createElement('th');
    taskNameHeader.onclick = () => sortTable('Task_Name');
    taskNameHeader.dataset.column = 'Task_Name';
    taskNameHeader.innerHTML = 'Task Name <span class="sort-indicator"></span>';
    headerRow.appendChild(taskNameHeader);
    
    // Add market headers with vertical text
    markets.forEach(market => {
        const marketHeader = document.createElement('th');
        marketHeader.className = 'market-header';
        marketHeader.onclick = () => sortTable(market);
        marketHeader.dataset.column = market;
        marketHeader.innerHTML = `<span class="market-header-text">${market}</span>`;
        headerRow.appendChild(marketHeader);
    });
    
    tableHeader.appendChild(headerRow);
    
    // Calculate pagination
    const startIndex = (currentPage - 1) * CONFIG.maxRowsPerPage;
    const endIndex = Math.min(startIndex + CONFIG.maxRowsPerPage, filteredData.length);
    const pageData = filteredData.slice(startIndex, endIndex);
    
    // Create rows (without Item ID)
    pageData.forEach(skill => {
        const row = document.createElement('tr');
        const mapping = taskMapping.find(t => t.Item_ID == skill.Item_ID);
        
        // Add main columns
        const categoryCell = document.createElement('td');
        categoryCell.textContent = skill.Category || '';
        row.appendChild(categoryCell);
        
        const taskGroupCell = document.createElement('td');
        taskGroupCell.textContent = skill.Task_Group || '';
        row.appendChild(taskGroupCell);
        
        const taskNameCell = document.createElement('td');
        taskNameCell.textContent = skill.Task_Name || '';
        row.appendChild(taskNameCell);
        
        // Add market cells
        markets.forEach(market => {
            const marketCell = document.createElement('td');
            marketCell.className = 'market-cell';
            
            const value = skill[market];
            const isApplicable = mapping && mapping[market] === 'x';
            
            if (!isApplicable) {
                marketCell.classList.add('na-cell');
                marketCell.innerHTML = '<span class="skill-na">N/A</span>';
            } else if (value && value.toString().toLowerCase() === 'yes') {
                marketCell.innerHTML = '<span class="skill-yes">YES</span>';
            } else {
                marketCell.innerHTML = '<span class="skill-no">NO</span>';
            }
            
            row.appendChild(marketCell);
        });
        
        tableBody.appendChild(row);
    });
    
    // Update pagination
    updatePagination();
    updatePaginationInfo(startIndex + 1, endIndex, filteredData.length);
}

// Sort table
function sortTable(column) {
    // Toggle sort direction if clicking the same column
    if (sortColumn === column) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        sortColumn = column;
        sortDirection = 'asc';
    }
    
    // Sort the filtered data
    filteredData.sort((a, b) => {
        let aVal = a[column];
        let bVal = b[column];
        
        // Handle null/undefined values
        if (aVal === null || aVal === undefined) aVal = '';
        if (bVal === null || bVal === undefined) bVal = '';
        
        // Convert to lowercase for string comparison
        if (typeof aVal === 'string') aVal = aVal.toLowerCase();
        if (typeof bVal === 'string') bVal = bVal.toLowerCase();
        
        // Compare values
        if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
        if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
        return 0;
    });
    
    // Update sort indicators
    const headers = document.querySelectorAll('#tableHeader th');
    headers.forEach(header => {
        header.classList.remove('sort-asc', 'sort-desc');
        if (header.dataset.column === column) {
            header.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
        }
    });
    
    // Re-render table
    currentPage = 1;
    renderTable();
}

// Update pagination info
function updatePaginationInfo(from, to, total) {
    document.getElementById('showingFrom').textContent = from;
    document.getElementById('showingTo').textContent = to;
    document.getElementById('totalRecords').textContent = total;
}

// Update pagination controls
function updatePagination() {
    const totalPages = Math.ceil(filteredData.length / CONFIG.maxRowsPerPage);
    const paginationControls = document.getElementById('paginationControls');
    paginationControls.innerHTML = '';
    
    if (totalPages <= 1) return;
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.className = 'page-btn';
    prevBtn.textContent = 'Previous';
    prevBtn.disabled = currentPage === 1;
    prevBtn.onclick = () => {
        if (currentPage > 1) {
            currentPage--;
            renderTable();
        }
    };
    paginationControls.appendChild(prevBtn);
    
    // Page numbers
    let startPage = Math.max(1, currentPage - 2);
    let endPage = Math.min(totalPages, startPage + 4);
    
    if (endPage - startPage < 4) {
        startPage = Math.max(1, endPage - 4);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageBtn = document.createElement('button');
        pageBtn.className = 'page-btn' + (i === currentPage ? ' active' : '');
        pageBtn.textContent = i;
        pageBtn.onclick = () => {
            currentPage = i;
            renderTable();
        };
        paginationControls.appendChild(pageBtn);
    }
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.className = 'page-btn';
    nextBtn.textContent = 'Next';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.onclick = () => {
        if (currentPage < totalPages) {
            currentPage++;
            renderTable();
        }
    };
    paginationControls.appendChild(nextBtn);
}

// Update statistics
function updateStatistics() {
    if (!userSkills || userSkills.length === 0) {
        document.getElementById('completedTasks').textContent = '0';
        document.getElementById('pendingTasks').textContent = '0';
        document.getElementById('totalTasks').textContent = '0';
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('progressText').textContent = '0% Complete';
        return;
    }
    
    const markets = Object.keys(userSkills[0] || {}).filter(key => 
        !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
    );
    
    let totalTasks = 0;
    let completedTasks = 0;
    const categoryStats = {};
    const taskGroupStats = {};
    
    userSkills.forEach(skill => {
        if (!categoryStats[skill.Category]) {
            categoryStats[skill.Category] = { total: 0, completed: 0 };
        }
        if (!taskGroupStats[skill.Task_Group]) {
            taskGroupStats[skill.Task_Group] = { total: 0, completed: 0 };
        }
        
        markets.forEach(market => {
            const mapping = taskMapping.find(t => t.Item_ID == skill.Item_ID);
            if (mapping && mapping[market] === 'x') {
                totalTasks++;
                categoryStats[skill.Category].total++;
                taskGroupStats[skill.Task_Group].total++;
                
                if (skill[market] && skill[market].toString().toLowerCase() === 'yes') {
                    completedTasks++;
                    categoryStats[skill.Category].completed++;
                    taskGroupStats[skill.Task_Group].completed++;
                }
            }
        });
    });
    
    // Update task summary
    document.getElementById('completedTasks').textContent = completedTasks;
    document.getElementById('pendingTasks').textContent = totalTasks - completedTasks;
    document.getElementById('totalTasks').textContent = totalTasks;
    
    // Update progress bar
    const percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
    document.getElementById('progressFill').style.width = `${percentage}%`;
    document.getElementById('progressText').textContent = `${percentage}% Complete`;
    
    // Update category stats
    const categoryStatsDiv = document.getElementById('categoryStats');
    categoryStatsDiv.innerHTML = '';
    
    Object.entries(categoryStats).forEach(([category, stats]) => {
        const percentage = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
        const item = document.createElement('div');
        item.className = 'category-item';
        item.innerHTML = `
            <span class="category-name">${category}</span>
            <div class="category-progress">
                <div class="mini-progress">
                    <div class="mini-progress-fill" style="width: ${percentage}%"></div>
                </div>
                <span class="category-percentage">${percentage}%</span>
            </div>
        `;
        categoryStatsDiv.appendChild(item);
    });
    
    // Update task group stats
    const taskGroupStatsDiv = document.getElementById('taskGroupStats');
    if (taskGroupStatsDiv) {
        taskGroupStatsDiv.innerHTML = '';
        
        Object.entries(taskGroupStats).forEach(([taskGroup, stats]) => {
            const percentage = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
            const item = document.createElement('div');
            item.className = 'category-item';
            item.innerHTML = `
                <span class="category-name">${taskGroup}</span>
                <div class="category-progress">
                    <div class="mini-progress">
                        <div class="mini-progress-fill" style="width: ${percentage}%"></div>
                    </div>
                    <span class="category-percentage">${percentage}%</span>
                </div>
            `;
            taskGroupStatsDiv.appendChild(item);
        });
    }
}

// Initialize market coverage chart
function initializeChart() {
    if (!userSkills || userSkills.length === 0) return;
    
    const ctx = document.getElementById('marketChart').getContext('2d');
    const markets = Object.keys(userSkills[0] || {}).filter(key => 
        !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
    );
    
    const marketData = markets.map(market => {
        let total = 0;
        let completed = 0;
        
        userSkills.forEach(skill => {
            const mapping = taskMapping.find(t => t.Item_ID == skill.Item_ID);
            if (mapping && mapping[market] === 'x') {
                total++;
                if (skill[market] && skill[market].toString().toLowerCase() === 'yes') {
                    completed++;
                }
            }
        });
        
        return total > 0 ? Math.round((completed / total) * 100) : 0;
    });
    
    if (marketChart) {
        marketChart.destroy();
    }
    
    marketChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: markets,
            datasets: [{
                label: 'Coverage %',
                data: marketData,
                backgroundColor: 'rgba(48, 86, 211, 0.8)',
                borderColor: 'rgba(48, 86, 211, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.parsed.y + '%';
                        }
                    }
                }
            }
        }
    });
}

// Open edit skills modal
function openEditModal() {
    if (!userSkills || userSkills.length === 0) {
        showToast('No skills data available to edit', 'warning');
        return;
    }
    
    const modal = document.getElementById('editSkillsModal');
    const grid = document.getElementById('skillsEditGrid');
    grid.innerHTML = '';
    
    // Setup category filter
    const modalFilter = document.getElementById('modalCategoryFilter');
    modalFilter.innerHTML = '<option value="">All Categories</option>';
    
    // Group skills by category
    const categories = {};
    userSkills.forEach(skill => {
        if (!categories[skill.Category]) {
            categories[skill.Category] = [];
        }
        categories[skill.Category].push(skill);
    });
    
    // Add category options to filter
    Object.keys(categories).forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        modalFilter.appendChild(option);
    });
    
    // Store categories globally for filtering
    window.modalCategories = categories;
    
    // Create skill edit interface for all categories
    displayModalCategories(categories);
    
    modal.classList.add('active');
}

// Display categories in modal based on filter
function displayModalCategories(categoriesToShow) {
    const grid = document.getElementById('skillsEditGrid');
    grid.innerHTML = '';
    
    Object.entries(categoriesToShow).forEach(([category, skills]) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'skill-category';
        categoryDiv.dataset.category = category;
        
        let categoryHtml = `<div class="skill-category-title">${category}</div>`;
        categoryHtml += '<div class="skill-tasks">';
        
        skills.forEach(skill => {
            const mapping = taskMapping.find(t => t.Item_ID == skill.Item_ID);
            const markets = Object.keys(skill).filter(key => 
                !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
            );
            
            categoryHtml += `
                <div class="skill-task" data-item-id="${skill.Item_ID}">
                    <div class="task-name">${skill.Task_Name}</div>
                    <div class="market-checkboxes">
            `;
            
            markets.forEach(market => {
                const isApplicable = mapping && mapping[market] === 'x';
                const isChecked = skill[market] && skill[market].toString().toLowerCase() === 'yes';
                const disabled = !isApplicable ? 'disabled' : '';
                
                categoryHtml += `
                    <div class="market-checkbox ${disabled}">
                        <input type="checkbox" 
                               id="skill_${skill.Item_ID}_${market}" 
                               data-item-id="${skill.Item_ID}"
                               data-market="${market}"
                               ${isChecked ? 'checked' : ''} 
                               ${disabled}>
                        <label for="skill_${skill.Item_ID}_${market}">${market}</label>
                    </div>
                `;
            });
            
            categoryHtml += '</div></div>';
        });
        
        categoryHtml += '</div>';
        categoryDiv.innerHTML = categoryHtml;
        grid.appendChild(categoryDiv);
    });
}

// Filter modal categories
function filterModalCategories() {
    const filterValue = document.getElementById('modalCategoryFilter').value;
    
    if (!filterValue) {
        // Show all categories
        displayModalCategories(window.modalCategories);
    } else {
        // Show only selected category
        const filtered = {};
        filtered[filterValue] = window.modalCategories[filterValue];
        displayModalCategories(filtered);
    }
}

// Close edit modal
function closeEditModal() {
    document.getElementById('editSkillsModal').classList.remove('active');
}

// Submit skill changes for approval
async function submitSkillChanges() {
    const changes = [];
    const checkboxes = document.querySelectorAll('#skillsEditGrid input[type="checkbox"]:not(:disabled)');
    
    checkboxes.forEach(checkbox => {
        const itemId = parseInt(checkbox.dataset.itemId);
        const market = checkbox.dataset.market;
        const currentSkill = userSkills.find(s => s.Item_ID == itemId);
        
        if (currentSkill) {
            const currentValue = currentSkill[market] && currentSkill[market].toString().toLowerCase() === 'yes';
            const newValue = checkbox.checked;
            
            if (currentValue !== newValue) {
                changes.push({
                    Item_ID: itemId,
                    Task_Name: currentSkill.Task_Name,
                    Category: currentSkill.Category,
                    Task_Group: currentSkill.Task_Group,
                    Market: market,
                    Old_Value: currentValue ? 'yes' : 'no',
                    New_Value: newValue ? 'yes' : 'no'
                });
            }
        }
    });
    
    if (changes.length === 0) {
        showToast('No changes detected', 'info');
        return;
    }
    
    // Create approval request
    const requestId = Date.now();
    const approvalData = [];
    
    // Create a summary of all changes for approval
    changes.forEach(change => {
        const approvalRow = {
            'Request ID': requestId,
            'Username': currentUser.username,
            'Item_ID': change.Item_ID,
            'Category': change.Category,
            'Task_Group': change.Task_Group,
            'Task_Name': change.Task_Name,
            'Status': 'Pending',
            'Timestamp': new Date().toISOString()
        };
        
        // Add the specific market change
        approvalRow[change.Market] = change.New_Value;
        
        approvalData.push(approvalRow);
    });
    
    try {
        await updateApprovals(approvalData);
        showToast(`Skill update request #${requestId} has been submitted for approval`, 'success', 'Request Submitted');
        closeEditModal();
        await logAuditEntry('SKILL_UPDATE_REQUEST', `Submitted ${changes.length} skill changes for approval`);
    } catch (error) {
        console.error('Failed to submit changes:', error);
        showToast('Failed to submit changes. Please try again.', 'error');
    }
}

// Update approvals Excel file
async function updateApprovals(approvalData) {
    try {
        // Fetch current approvals
        const workbook = await fetchExcelData(CONFIG.files.approvals);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const currentApprovals = XLSX.utils.sheet_to_json(worksheet);
        
        // Add new approvals
        const updatedApprovals = [...currentApprovals, ...approvalData];
        
        // Create new worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(updatedApprovals);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Convert to binary
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        
        // Upload updated file
        await API.uploadAttachment(CONFIG.files.approvals, blob);
        
        console.log('Approvals updated successfully');
        
    } catch (error) {
        console.error('Failed to update approvals:', error);
        throw error;
    }
}

// Open notifications modal
function openNotificationsModal() {
    const modal = document.getElementById('notificationsModal');
    const list = document.getElementById('notificationsList');
    list.innerHTML = '';
    
    if (notifications.length === 0) {
        list.innerHTML = '<p style="text-align: center; padding: 20px; color: #64748B;">No notifications</p>';
    } else {
        notifications.forEach(notification => {
            const item = document.createElement('div');
            const status = notification.Status ? notification.Status.toLowerCase() : 'pending';
            item.className = `notification-item ${status}`;
            item.innerHTML = `
                <div class="notification-content">
                    <div class="notification-title">Request #${notification['Request ID']}</div>
                    <div class="notification-message">
                        Your ${notification['Request Type'] || 'Skill Update'} request has been ${notification.Status || 'processed'}
                    </div>
                    <div class="notification-time">${formatDate(notification.Timestamp)}</div>
                </div>
                <span class="notification-status ${status}">
                    ${notification.Status || 'PENDING'}
                </span>
            `;
            list.appendChild(item);
        });
    }
    
    modal.classList.add('active');
}

// Close notifications modal
function closeNotificationsModal() {
    document.getElementById('notificationsModal').classList.remove('active');
}

// Clear notifications
async function clearNotifications() {
    if (notifications.length === 0) {
        closeNotificationsModal();
        return;
    }
    
    try {
        // Remove notifications for current user
        const workbook = await fetchExcelData(CONFIG.files.notifications);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const allNotifications = XLSX.utils.sheet_to_json(worksheet);
        
        // Filter out current user's notifications
        const updatedNotifications = allNotifications.filter(n => n.Username !== currentUser.username);
        
        // Update worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(updatedNotifications);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Save and upload
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.notifications, blob);
        
        // Clear local notifications
        notifications = [];
        document.getElementById('notificationBadge').style.display = 'none';
        closeNotificationsModal();
        
        await logAuditEntry('NOTIFICATIONS_CLEARED', `Cleared all notifications for user ${currentUser.username}`);
        
        showToast('All notifications cleared', 'success');
        
    } catch (error) {
        console.error('Failed to clear notifications:', error);
        showToast('Failed to clear notifications', 'error');
    }
}

// Export data
function exportData() {
    if (!filteredData || filteredData.length === 0) {
        showToast('No data to export', 'warning');
        return;
    }
    
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(filteredData);
    XLSX.utils.book_append_sheet(wb, ws, 'My Skills');
    XLSX.writeFile(wb, `my_skills_${currentUser.username}_${new Date().getTime()}.xlsx`);
    
    showToast('Data exported successfully', 'success');
    logAuditEntry('DATA_EXPORTED', `Exported ${filteredData.length} skill records`);
}

// Log audit entry
async function logAuditEntry(action, details) {
    try {
        // This would log to audit_log.xlsx if implemented
        console.log('Audit log:', {
            timestamp: new Date().toISOString(),
            user: currentUser.username,
            action: action,
            details: details
        });
    } catch (error) {
        console.error('Failed to log audit entry:', error);
    }
}

// Utility functions
function formatDate(dateString) {
    if (!dateString) return '';
    try {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    } catch (e) {
        return dateString;
    }
}

function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.toggle('active', show);
    }
}

function showError(message) {
    showToast(message, 'error');
    console.error(message);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}