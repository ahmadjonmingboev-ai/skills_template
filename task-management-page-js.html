// Task Management Page JavaScript with Confluence REST API Integration

// Include required libraries (add these script tags to your Confluence page)
// <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

// Configuration
const CONFIG = {
    confluence: {
        domain: 'https://www.myconfluence.net',  // Update with actual domain
        pageId: '123345346',
        api: {
            currentUser: '/rest/api/user/current',
            attachment: '/rest/api/content/{pageId}/child/attachment'
        }
    },
    files: {
        userDatabase: 'userdatabase.xlsx',
        mainTaskDatabase: 'maintaskdatabase.xlsx',
        taskMapping: 'taskmapping.xlsx',
        auditLog: 'audit_log.xlsx'
    },
    maxRowsPerPage: 50
};

// API Helper Functions
const API = {
    getCurrentUser: async function() {
        try {
            const response = await fetch(CONFIG.confluence.domain + CONFIG.confluence.api.currentUser, {
                credentials: 'same-origin'
            });
            if (!response.ok) {
                console.warn('User API returned:', response.status);
                return null;
            }
            const userData = await response.json();
            const normalizedUser = {
                displayName: userData.displayName || userData.fullName || userData.name || 'Unknown',
                key: userData.key || userData.username || userData.accountId || userData.name || userData.userName,
                email: userData.emailAddress || userData.email,
                ...userData
            };
            return normalizedUser;
        } catch (error) {
            console.warn('Error fetching current user:', error);
            return null;
        }
    },
    
    getAttachments: async function() {
        try {
            const url = CONFIG.confluence.domain +
                       CONFIG.confluence.api.attachment.replace('{pageId}', CONFIG.confluence.pageId);
            const response = await fetch(url, {
                credentials: 'same-origin'
            });
            if (!response.ok) throw new Error('Failed to fetch attachments');
            const data = await response.json();
            return data.results || [];
        } catch (error) {
            console.error('Error fetching attachments:', error);
            return [];
        }
    },
    
    downloadAttachment: async function(attachmentUrl) {
        try {
            const url = attachmentUrl.startsWith('http') ? attachmentUrl : CONFIG.confluence.domain + attachmentUrl;
            const response = await fetch(url, {
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                }
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            return arrayBuffer;
        } catch (error) {
            console.error('Error downloading attachment:', error);
            return null;
        }
    },
    
    uploadAttachment: async function(filename, blob) {
        try {
            const attachments = await this.getAttachments();
            const existingAttachment = attachments.find(att => att.title === filename);
            
            if (!existingAttachment) {
                throw new Error(`Attachment ${filename} not found`);
            }
            
            const formData = new FormData();
            formData.append('file', blob, filename);
            formData.append('minorEdit', 'true');
            formData.append('comment', 'Updated by Task Management System');
            
            // Try multiple upload methods
            let url, response;
            
            // Method 1: Update existing attachment
            try {
                url = `${CONFIG.confluence.domain}/rest/api/content/${existingAttachment.id}/child/attachment/${existingAttachment.id}/data`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 1 failed, trying method 2');
            }
            
            // Method 2: Create new version
            try {
                url = `${CONFIG.confluence.domain}/rest/api/content/${CONFIG.confluence.pageId}/child/attachment`;
                response = await fetch(url, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Atlassian-Token': 'no-check'
                    }
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('Method 2 failed');
            }
            
            throw new Error('Failed to upload attachment');
            
        } catch (error) {
            console.error('Error uploading attachment:', error);
            throw error;
        }
    }
};

// Global variables
let currentUser = null;
let allUsers = [];
let allTasks = [];
let taskMapping = [];
let filteredTasks = [];
let filteredMappings = [];
let availableMarkets = [];
let currentTaskPage = 1;
let currentMappingPage = 1;
let attachments = {};
let taskToDelete = null;
let mainWorkbook = null;

// Initialize the application
async function initializeApp() {
    showLoading(true, 'Loading task management...');
    try {
        // Get current user from Confluence
        const confluenceUser = await API.getCurrentUser();
        if (!confluenceUser) {
            showToast('Could not get current user. Please ensure you are logged into Confluence.', 'error');
            return;
        }
        
        currentUser = {
            username: confluenceUser.key,
            displayName: confluenceUser.displayName,
            email: confluenceUser.email
        };
        
        // Load all attachments first
        await loadAttachments();
        
        // Check if user is admin
        const hasAccess = await checkAdminAccess();
        if (!hasAccess) {
            showNoAccess();
            return;
        }
        
        // Load all necessary data
        await loadTaskData();
        await loadMappingData();
        
        // Initialize UI
        initializeUI();
        
    } catch (error) {
        console.error('Initialization error:', error);
        showToast('Failed to initialize application. Please refresh the page.', 'error');
    } finally {
        showLoading(false);
    }
}

// Load all attachments
async function loadAttachments() {
    const attachmentList = await API.getAttachments();
    attachmentList.forEach(att => {
        attachments[att.title] = att._links.download || att._links.webui;
    });
}

// Fetch and parse Excel file
async function fetchExcelData(filename) {
    try {
        const downloadUrl = attachments[filename];
        if (!downloadUrl) {
            throw new Error(`Attachment ${filename} not found`);
        }
        
        const arrayBuffer = await API.downloadAttachment(downloadUrl);
        if (!arrayBuffer) {
            throw new Error(`Failed to download ${filename}`);
        }
        
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        return workbook;
        
    } catch (error) {
        console.error(`Error fetching ${filename}:`, error);
        throw error;
    }
}

// Check admin access
async function checkAdminAccess() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.userDatabase);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        allUsers = XLSX.utils.sheet_to_json(worksheet);
        
        const userData = allUsers.find(u => u.username === currentUser.username);
        if (!userData) {
            // Fallback for testing
            userData = allUsers.find(u => u.username === 'BD12345');
        }
        
        if (!userData) {
            return false;
        }
        
        currentUser = { ...currentUser, ...userData };
        
        // Only admins can access this page
        return userData.role === 'admin';
        
    } catch (error) {
        console.error('Failed to check admin access:', error);
        return false;
    }
}

// Load task data from template sheet
async function loadTaskData() {
    try {
        mainWorkbook = await fetchExcelData(CONFIG.files.mainTaskDatabase);
        const templateSheet = mainWorkbook.Sheets['Template'] || mainWorkbook.Sheets[mainWorkbook.SheetNames[0]];
        
        if (templateSheet) {
            allTasks = XLSX.utils.sheet_to_json(templateSheet);
        } else {
            allTasks = [];
        }
        
        // Update statistics
        const categories = [...new Set(allTasks.map(t => t.Category))].filter(Boolean);
        document.getElementById('totalTasks').textContent = allTasks.length;
        document.getElementById('totalCategories').textContent = categories.length;
        
        console.log('Loaded tasks:', allTasks.length);
        
    } catch (error) {
        console.error('Failed to load task data:', error);
        allTasks = [];
    }
}

// Load mapping data
async function loadMappingData() {
    try {
        const workbook = await fetchExcelData(CONFIG.files.taskMapping);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        taskMapping = XLSX.utils.sheet_to_json(worksheet);
        
        // Extract available markets from the first mapping row
        if (taskMapping.length > 0) {
            availableMarkets = Object.keys(taskMapping[0]).filter(key => 
                !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
            );
        }
        
        console.log('Loaded mappings:', taskMapping.length);
        console.log('Available markets:', availableMarkets);
        
    } catch (error) {
        console.error('Failed to load mapping data:', error);
        taskMapping = [];
    }
}

// Initialize UI
function initializeUI() {
    setupFilters();
    filterTasks();
    filterMappings();
}

// Setup filter dropdowns
function setupFilters() {
    // Task filters
    const categories = [...new Set(allTasks.map(t => t.Category))].filter(Boolean);
    const groups = [...new Set(allTasks.map(t => t.Task_Group))].filter(Boolean);
    
    const categoryFilter = document.getElementById('taskCategoryFilter');
    categoryFilter.innerHTML = '<option value="">All Categories</option>';
    categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categoryFilter.appendChild(option);
    });
    
    const groupFilter = document.getElementById('taskGroupFilter');
    groupFilter.innerHTML = '<option value="">All Task Groups</option>';
    groups.forEach(group => {
        const option = document.createElement('option');
        option.value = group;
        option.textContent = group;
        groupFilter.appendChild(option);
    });
    
    // Mapping filters
    const mappingCategoryFilter = document.getElementById('mappingCategoryFilter');
    mappingCategoryFilter.innerHTML = '<option value="">All Categories</option>';
    categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        mappingCategoryFilter.appendChild(option);
    });
    
    const marketFilter = document.getElementById('mappingMarketFilter');
    marketFilter.innerHTML = '<option value="">All Markets</option>';
    availableMarkets.forEach(market => {
        const option = document.createElement('option');
        option.value = market;
        option.textContent = market;
        marketFilter.appendChild(option);
    });
}

// Filter tasks
function filterTasks() {
    const searchTerm = document.getElementById('taskSearchInput').value.toLowerCase();
    const categoryFilter = document.getElementById('taskCategoryFilter').value;
    const groupFilter = document.getElementById('taskGroupFilter').value;
    
    filteredTasks = allTasks.filter(task => {
        const matchesSearch = !searchTerm || 
            (task.Item_ID && task.Item_ID.toString().toLowerCase().includes(searchTerm)) ||
            (task.Category && task.Category.toLowerCase().includes(searchTerm)) ||
            (task.Task_Group && task.Task_Group.toLowerCase().includes(searchTerm)) ||
            (task.Task_Name && task.Task_Name.toLowerCase().includes(searchTerm));
        
        const matchesCategory = !categoryFilter || task.Category === categoryFilter;
        const matchesGroup = !groupFilter || task.Task_Group === groupFilter;
        
        return matchesSearch && matchesCategory && matchesGroup;
    });
    
    currentTaskPage = 1;
    renderTasksTable();
}

// Render tasks table
function renderTasksTable() {
    const tbody = document.getElementById('tasksTableBody');
    const emptyState = document.getElementById('tasksEmptyState');
    
    tbody.innerHTML = '';
    
    if (filteredTasks.length === 0) {
        document.getElementById('tasksTable').style.display = 'none';
        emptyState.style.display = 'flex';
        updateTaskPaginationInfo(0, 0, 0);
        return;
    }
    
    document.getElementById('tasksTable').style.display = 'table';
    emptyState.style.display = 'none';
    
    // Paginate
    const startIndex = (currentTaskPage - 1) * CONFIG.maxRowsPerPage;
    const endIndex = Math.min(startIndex + CONFIG.maxRowsPerPage, filteredTasks.length);
    const pageData = filteredTasks.slice(startIndex, endIndex);
    
    // Render rows
    pageData.forEach((task, index) => {
        const row = document.createElement('tr');
        // Store task data in data attributes to avoid escaping issues
        row.setAttribute('data-task-id', task.Item_ID);
        row.setAttribute('data-task-index', startIndex + index);
        
        row.innerHTML = `
            <td>${task.Item_ID || ''}</td>
            <td>${task.Category || ''}</td>
            <td>${task.Task_Group || ''}</td>
            <td>${task.Task_Name || ''}</td>
            <td>
                <div class="task-actions">
                    <button class="task-action-btn edit" onclick="editTaskByIndex(${startIndex + index})">
                        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                        </svg>
                        Edit
                    </button>
                    <button class="task-action-btn delete" onclick="deleteTaskByIndex(${startIndex + index})">
                        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                        </svg>
                        Delete
                    </button>
                </div>
            </td>
        `;
        tbody.appendChild(row);
    });
    
    updateTaskPagination();
    updateTaskPaginationInfo(startIndex + 1, endIndex, filteredTasks.length);
}

// Edit task by index
function editTaskByIndex(index) {
    const task = filteredTasks[index];
    if (task) {
        editTask(task.Item_ID);
    }
}

// Delete task by index
function deleteTaskByIndex(index) {
    const task = filteredTasks[index];
    if (task) {
        deleteTask(task.Item_ID);
    }
}

// Filter mappings
function filterMappings() {
    const searchTerm = document.getElementById('mappingSearchInput').value.toLowerCase();
    const categoryFilter = document.getElementById('mappingCategoryFilter').value;
    const marketFilter = document.getElementById('mappingMarketFilter').value;
    
    filteredMappings = taskMapping.filter(mapping => {
        const matchesSearch = !searchTerm || 
            (mapping.Item_ID && mapping.Item_ID.toString().toLowerCase().includes(searchTerm)) ||
            (mapping.Category && mapping.Category.toLowerCase().includes(searchTerm)) ||
            (mapping.Task_Group && mapping.Task_Group.toLowerCase().includes(searchTerm)) ||
            (mapping.Task_Name && mapping.Task_Name.toLowerCase().includes(searchTerm));
        
        const matchesCategory = !categoryFilter || mapping.Category === categoryFilter;
        
        // Check if task has the selected market
        let matchesMarket = true;
        if (marketFilter) {
            matchesMarket = mapping[marketFilter] === 'x';
        }
        
        return matchesSearch && matchesCategory && matchesMarket;
    });
    
    currentMappingPage = 1;
    renderMappingTable();
}

// Render mapping table
function renderMappingTable() {
    const thead = document.getElementById('mappingTableHead');
    const tbody = document.getElementById('mappingTableBody');
    const emptyState = document.getElementById('mappingEmptyState');
    
    // Create headers
    thead.innerHTML = `
        <tr>
            <th>Item ID</th>
            <th>Category</th>
            <th>Task Group</th>
            <th>Task Name</th>
            ${availableMarkets.map(market => `<th class="market-cell">${market}</th>`).join('')}
        </tr>
    `;
    
    tbody.innerHTML = '';
    
    if (filteredMappings.length === 0) {
        document.getElementById('mappingTable').style.display = 'none';
        emptyState.style.display = 'flex';
        updateMappingPaginationInfo(0, 0, 0);
        return;
    }
    
    document.getElementById('mappingTable').style.display = 'table';
    emptyState.style.display = 'none';
    
    // Paginate
    const startIndex = (currentMappingPage - 1) * CONFIG.maxRowsPerPage;
    const endIndex = Math.min(startIndex + CONFIG.maxRowsPerPage, filteredMappings.length);
    const pageData = filteredMappings.slice(startIndex, endIndex);
    
    // Render rows
    pageData.forEach(mapping => {
        const row = document.createElement('tr');
        const marketCells = availableMarkets.map(market => {
            const isChecked = mapping[market] === 'x';
            return `
                <td class="market-cell">
                    <input type="checkbox" 
                           class="market-toggle" 
                           ${isChecked ? 'checked' : ''}
                           onchange="toggleMarket('${mapping.Item_ID}', '${market}', this.checked)">
                </td>
            `;
        }).join('');
        
        row.innerHTML = `
            <td>${mapping.Item_ID}</td>
            <td>${mapping.Category}</td>
            <td>${mapping.Task_Group}</td>
            <td>${mapping.Task_Name}</td>
            ${marketCells}
        `;
        tbody.appendChild(row);
    });
    
    updateMappingPagination();
    updateMappingPaginationInfo(startIndex + 1, endIndex, filteredMappings.length);
}

// Generate unique task ID - only numbers
function generateTaskId() {
    const date = new Date();
    const dateStr = date.getFullYear().toString() +
                   (date.getMonth() + 1).toString().padStart(2, '0') +
                   date.getDate().toString().padStart(2, '0');
    
    // Generate 5 random digits
    let randomStr = '';
    for (let i = 0; i < 5; i++) {
        randomStr += Math.floor(Math.random() * 10).toString();
    }
    
    return dateStr + randomStr;  // e.g., "2025092812345"
}

// Open add task modal
function openAddTaskModal() {
    document.getElementById('taskModalTitle').textContent = 'Add New Task';
    document.getElementById('taskForm').reset();
    document.getElementById('taskEditMode').value = 'false';
    document.getElementById('taskItemId').value = '';
    
    // Setup market checkboxes
    const container = document.getElementById('marketCheckboxes');
    container.innerHTML = '';
    
    availableMarkets.forEach(market => {
        const checkbox = document.createElement('div');
        checkbox.className = 'market-checkbox';
        checkbox.innerHTML = `
            <input type="checkbox" id="market_${market}" value="${market}">
            <label for="market_${market}">${market}</label>
        `;
        container.appendChild(checkbox);
    });
    
    document.getElementById('taskModal').classList.add('active');
}

// Edit task
function editTask(itemId) {
    const task = allTasks.find(t => t.Item_ID === itemId);
    const mapping = taskMapping.find(m => m.Item_ID === itemId);
    
    if (!task) return;
    
    document.getElementById('taskModalTitle').textContent = 'Edit Task';
    document.getElementById('taskEditMode').value = 'true';
    document.getElementById('taskItemId').value = itemId;
    document.getElementById('taskCategory').value = task.Category;
    document.getElementById('taskGroup').value = task.Task_Group;
    document.getElementById('taskName').value = task.Task_Name;
    
    // Setup market checkboxes with current values
    const container = document.getElementById('marketCheckboxes');
    container.innerHTML = '';
    
    availableMarkets.forEach(market => {
        const isChecked = mapping && mapping[market] === 'x';
        const checkbox = document.createElement('div');
        checkbox.className = 'market-checkbox';
        checkbox.innerHTML = `
            <input type="checkbox" id="market_${market}" value="${market}" ${isChecked ? 'checked' : ''}>
            <label for="market_${market}">${market}</label>
        `;
        container.appendChild(checkbox);
    });
    
    document.getElementById('taskModal').classList.add('active');
}

// Save task
async function saveTask() {
    const isEditMode = document.getElementById('taskEditMode').value === 'true';
    const itemId = isEditMode ? document.getElementById('taskItemId').value : generateTaskId();
    const category = document.getElementById('taskCategory').value.trim();
    const taskGroup = document.getElementById('taskGroup').value.trim();
    const taskName = document.getElementById('taskName').value.trim();
    
    // Validation
    if (!category || !taskGroup || !taskName) {
        showToast('Please fill in all required fields', 'warning');
        return;
    }
    
    // Get selected markets
    const selectedMarkets = [];
    availableMarkets.forEach(market => {
        const checkbox = document.getElementById(`market_${market}`);
        if (checkbox && checkbox.checked) {
            selectedMarkets.push(market);
        }
    });
    
    showLoading(true, isEditMode ? 'Updating task...' : 'Adding task...');
    
    try {
        // Prepare task data
        const taskData = {
            Item_ID: itemId,
            Category: category,
            Task_Group: taskGroup,
            Task_Name: taskName
        };
        
        // Prepare mapping data
        const mappingData = { ...taskData };
        availableMarkets.forEach(market => {
            mappingData[market] = selectedMarkets.includes(market) ? 'x' : '';
        });
        
        if (isEditMode) {
            await updateExistingTask(itemId, taskData, mappingData);
        } else {
            await addNewTask(taskData, mappingData);
        }
        
        // Log to audit
        await logAudit(isEditMode ? 'EDIT_TASK' : 'ADD_TASK', itemId, 
            isEditMode ? `Updated task: ${taskName}` : `Added new task: ${taskName}`,
            '', JSON.stringify(taskData));
        
        closeTaskModal();
        showToast(`Task ${isEditMode ? 'updated' : 'added'} successfully`, 'success');
        
        // Reload data
        await loadTaskData();
        await loadMappingData();
        initializeUI();
        
    } catch (error) {
        console.error('Failed to save task:', error);
        showToast(`Failed to ${isEditMode ? 'update' : 'add'} task`, 'error');
    } finally {
        showLoading(false);
    }
}

// Add new task
async function addNewTask(taskData, mappingData) {
    // Update template sheet
    const templateSheet = mainWorkbook.Sheets['Template'] || mainWorkbook.Sheets[mainWorkbook.SheetNames[0]];
    const templateData = XLSX.utils.sheet_to_json(templateSheet);
    templateData.push(taskData);
    mainWorkbook.Sheets['Template'] = XLSX.utils.json_to_sheet(templateData);
    
    // Add to all user sheets
    const userSheets = mainWorkbook.SheetNames.filter(name => name !== 'Template');
    const userCount = userSheets.length;
    let processed = 0;
    
    for (const sheetName of userSheets) {
        const userData = XLSX.utils.sheet_to_json(mainWorkbook.Sheets[sheetName]);
        const newRow = { ...taskData };
        
        // Add all markets with NO as default
        availableMarkets.forEach(market => {
            newRow[market] = 'no';
        });
        
        userData.push(newRow);
        mainWorkbook.Sheets[sheetName] = XLSX.utils.json_to_sheet(userData);
        
        processed++;
        updateLoadingMessage(`Updating user sheets... (${processed}/${userCount})`);
    }
    
    // Save main workbook
    const wbout = XLSX.write(mainWorkbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    await API.uploadAttachment(CONFIG.files.mainTaskDatabase, blob);
    
    // Update task mapping
    const mappingWorkbook = await fetchExcelData(CONFIG.files.taskMapping);
    const mappingSheet = mappingWorkbook.Sheets[mappingWorkbook.SheetNames[0]];
    const mappingDataArray = XLSX.utils.sheet_to_json(mappingSheet);
    mappingDataArray.push(mappingData);
    mappingWorkbook.Sheets[mappingWorkbook.SheetNames[0]] = XLSX.utils.json_to_sheet(mappingDataArray);
    
    const mappingOut = XLSX.write(mappingWorkbook, { bookType: 'xlsx', type: 'array' });
    const mappingBlob = new Blob([mappingOut], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    await API.uploadAttachment(CONFIG.files.taskMapping, mappingBlob);
}

// Update existing task
async function updateExistingTask(itemId, taskData, mappingData) {
    // Update template sheet
    const templateSheet = mainWorkbook.Sheets['Template'] || mainWorkbook.Sheets[mainWorkbook.SheetNames[0]];
    const templateData = XLSX.utils.sheet_to_json(templateSheet);
    const taskIndex = templateData.findIndex(t => t.Item_ID === itemId);
    
    if (taskIndex !== -1) {
        templateData[taskIndex] = { ...templateData[taskIndex], ...taskData };
        mainWorkbook.Sheets['Template'] = XLSX.utils.json_to_sheet(templateData);
    }
    
    // Update all user sheets
    const userSheets = mainWorkbook.SheetNames.filter(name => name !== 'Template');
    const userCount = userSheets.length;
    let processed = 0;
    
    for (const sheetName of userSheets) {
        const userData = XLSX.utils.sheet_to_json(mainWorkbook.Sheets[sheetName]);
        const userTaskIndex = userData.findIndex(t => t.Item_ID === itemId);
        
        if (userTaskIndex !== -1) {
            // Keep the market values, only update task details
            userData[userTaskIndex] = {
                ...userData[userTaskIndex],
                Category: taskData.Category,
                Task_Group: taskData.Task_Group,
                Task_Name: taskData.Task_Name
            };
            mainWorkbook.Sheets[sheetName] = XLSX.utils.json_to_sheet(userData);
        }
        
        processed++;
        updateLoadingMessage(`Updating user sheets... (${processed}/${userCount})`);
    }
    
    // Save main workbook
    const wbout = XLSX.write(mainWorkbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    await API.uploadAttachment(CONFIG.files.mainTaskDatabase, blob);
    
    // Update task mapping
    const mappingWorkbook = await fetchExcelData(CONFIG.files.taskMapping);
    const mappingSheet = mappingWorkbook.Sheets[mappingWorkbook.SheetNames[0]];
    const mappingDataArray = XLSX.utils.sheet_to_json(mappingSheet);
    const mappingIndex = mappingDataArray.findIndex(m => m.Item_ID === itemId);
    
    if (mappingIndex !== -1) {
        mappingDataArray[mappingIndex] = mappingData;
    }
    
    mappingWorkbook.Sheets[mappingWorkbook.SheetNames[0]] = XLSX.utils.json_to_sheet(mappingDataArray);
    
    const mappingOut = XLSX.write(mappingWorkbook, { bookType: 'xlsx', type: 'array' });
    const mappingBlob = new Blob([mappingOut], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    await API.uploadAttachment(CONFIG.files.taskMapping, mappingBlob);
}

// Delete task
function deleteTask(itemId) {
    taskToDelete = itemId;
    
    // Count affected users - check if mainWorkbook is loaded
    if (mainWorkbook) {
        const userSheets = mainWorkbook.SheetNames.filter(name => name !== 'Template');
        document.getElementById('affectedUsersCount').textContent = userSheets.length;
    } else {
        // If mainWorkbook is not loaded, count from allUsers
        document.getElementById('affectedUsersCount').textContent = allUsers.length;
    }
    
    document.getElementById('deleteModal').classList.add('active');
}

// Confirm delete - FIXED to actually remove task
async function confirmDelete() {
    if (!taskToDelete) return;
    
    showLoading(true, 'Deleting task...');
    
    try {
        const task = allTasks.find(t => t.Item_ID === taskToDelete);
        
        // Reload fresh workbook to ensure we have latest data
        const workbook = await fetchExcelData(CONFIG.files.mainTaskDatabase);
        
        // Remove from template sheet
        const templateSheet = workbook.Sheets['Template'] || workbook.Sheets[workbook.SheetNames[0]];
        let templateData = XLSX.utils.sheet_to_json(templateSheet);
        templateData = templateData.filter(t => t.Item_ID !== taskToDelete);
        workbook.Sheets['Template'] = XLSX.utils.json_to_sheet(templateData);
        
        // Remove from all user sheets
        const userSheets = workbook.SheetNames.filter(name => name !== 'Template');
        const userCount = userSheets.length;
        let processed = 0;
        
        for (const sheetName of userSheets) {
            let userData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
            userData = userData.filter(t => t.Item_ID !== taskToDelete);
            workbook.Sheets[sheetName] = XLSX.utils.json_to_sheet(userData);
            
            processed++;
            updateLoadingMessage(`Removing from user sheets... (${processed}/${userCount})`);
        }
        
        // Save main workbook
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.mainTaskDatabase, blob);
        
        // Remove from task mapping
        const mappingWorkbook = await fetchExcelData(CONFIG.files.taskMapping);
        const mappingSheet = mappingWorkbook.Sheets[mappingWorkbook.SheetNames[0]];
        let mappingData = XLSX.utils.sheet_to_json(mappingSheet);
        mappingData = mappingData.filter(m => m.Item_ID !== taskToDelete);
        mappingWorkbook.Sheets[mappingWorkbook.SheetNames[0]] = XLSX.utils.json_to_sheet(mappingData);
        
        const mappingOut = XLSX.write(mappingWorkbook, { bookType: 'xlsx', type: 'array' });
        const mappingBlob = new Blob([mappingOut], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.taskMapping, mappingBlob);
        
        // Log to audit
        await logAudit('DELETE_TASK', taskToDelete, 
            `Deleted task: ${task ? task.Task_Name : taskToDelete}`,
            JSON.stringify(task), '');
        
        closeDeleteModal();
        showToast('Task deleted successfully', 'success');
        
        // Reload data to reflect changes
        await loadTaskData();
        await loadMappingData();
        initializeUI();
        
    } catch (error) {
        console.error('Failed to delete task:', error);
        showToast('Failed to delete task', 'error');
    } finally {
        showLoading(false);
    }
}

// Toggle market in mapping - FIXED to actually save changes
async function toggleMarket(itemId, market, isEnabled) {
    showLoading(true, 'Updating market mapping...');
    
    try {
        // Reload fresh workbook to ensure we have latest data
        const workbook = await fetchExcelData(CONFIG.files.taskMapping);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        let mappingData = XLSX.utils.sheet_to_json(worksheet);
        
        // Find the mapping for this task
        const mappingIndex = mappingData.findIndex(m => m.Item_ID === itemId);
        if (mappingIndex === -1) {
            throw new Error(`Mapping not found for Item_ID: ${itemId}`);
        }
        
        const oldValue = mappingData[mappingIndex][market] || '';
        const newValue = isEnabled ? 'x' : '';
        
        // Update the mapping
        mappingData[mappingIndex][market] = newValue;
        
        // Save the updated mapping back to the workbook
        const newWorksheet = XLSX.utils.json_to_sheet(mappingData);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Write and upload the file
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.taskMapping, blob);
        
        // Update local data
        const localMapping = taskMapping.find(m => m.Item_ID === itemId);
        if (localMapping) {
            localMapping[market] = newValue;
        }
        
        // Log to audit
        await logAudit('UPDATE_MAPPING', itemId, 
            `Updated market ${market} for task ${itemId}: ${isEnabled ? 'Enabled' : 'Disabled'}`,
            oldValue, newValue);
        
        showToast(`Market ${market} ${isEnabled ? 'enabled' : 'disabled'} for task ${itemId}`, 'success');
        
    } catch (error) {
        console.error('Failed to update market mapping:', error);
        showToast('Failed to update market mapping', 'error');
        
        // Revert checkbox on error
        const checkboxes = document.querySelectorAll('.market-toggle');
        checkboxes.forEach(cb => {
            const row = cb.closest('tr');
            if (row) {
                const itemIdCell = row.cells[0];
                if (itemIdCell && itemIdCell.textContent === itemId) {
                    const marketIndex = Array.from(row.cells).indexOf(cb.closest('td')) - 4; // Adjust for non-market columns
                    if (marketIndex >= 0 && marketIndex < availableMarkets.length && availableMarkets[marketIndex] === market) {
                        cb.checked = !cb.checked;
                    }
                }
            }
        });
    } finally {
        showLoading(false);
    }
}

// Log to audit
async function logAudit(action, itemId, details, previousValue = '', newValue = '') {
    try {
        let auditData = [];
        
        // Try to load existing audit log
        try {
            const workbook = await fetchExcelData(CONFIG.files.auditLog);
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            auditData = XLSX.utils.sheet_to_json(worksheet);
        } catch (e) {
            console.log('No existing audit log, creating new one');
        }
        
        // Add new audit entry
        auditData.push({
            Timestamp: new Date().toISOString(),
            User: currentUser.username,
            Action: action,
            Item_ID: itemId,
            Details: details,
            Previous_Value: previousValue,
            New_Value: newValue
        });
        
        // Save audit log
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.json_to_sheet(auditData);
        XLSX.utils.book_append_sheet(wb, ws, 'Audit Log');
        
        const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        await API.uploadAttachment(CONFIG.files.auditLog, blob);
        
    } catch (error) {
        console.error('Failed to log audit:', error);
    }
}

// Switch tabs
function switchTaskTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.task-tab').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.closest('.task-tab').classList.add('active');
    
    // Update tab content
    document.querySelectorAll('.tab-pane').forEach(pane => {
        pane.classList.remove('active');
    });
    
    if (tab === 'database') {
        document.getElementById('databaseTab').classList.add('active');
    } else if (tab === 'mapping') {
        document.getElementById('mappingTab').classList.add('active');
    }
}

// Select/Deselect all markets
function selectAllMarkets() {
    availableMarkets.forEach(market => {
        const checkbox = document.getElementById(`market_${market}`);
        if (checkbox) checkbox.checked = true;
    });
}

function deselectAllMarkets() {
    availableMarkets.forEach(market => {
        const checkbox = document.getElementById(`market_${market}`);
        if (checkbox) checkbox.checked = false;
    });
}

// Export tasks
function exportTasks() {
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(filteredTasks);
    XLSX.utils.book_append_sheet(wb, ws, 'Tasks');
    XLSX.writeFile(wb, `tasks_export_${new Date().getTime()}.xlsx`);
    showToast('Tasks exported successfully', 'success');
}

// Export mappings
function exportMappings() {
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(filteredMappings);
    XLSX.utils.book_append_sheet(wb, ws, 'Task Mappings');
    XLSX.writeFile(wb, `mappings_export_${new Date().getTime()}.xlsx`);
    showToast('Mappings exported successfully', 'success');
}

// Pagination functions
function updateTaskPagination() {
    const totalPages = Math.ceil(filteredTasks.length / CONFIG.maxRowsPerPage);
    const controls = document.getElementById('taskPaginationControls');
    controls.innerHTML = '';
    
    if (totalPages <= 1) return;
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.className = 'page-btn';
    prevBtn.textContent = 'Previous';
    prevBtn.disabled = currentTaskPage === 1;
    prevBtn.onclick = () => {
        if (currentTaskPage > 1) {
            currentTaskPage--;
            renderTasksTable();
        }
    };
    controls.appendChild(prevBtn);
    
    // Page numbers
    for (let i = 1; i <= Math.min(totalPages, 5); i++) {
        const pageBtn = document.createElement('button');
        pageBtn.className = 'page-btn' + (i === currentTaskPage ? ' active' : '');
        pageBtn.textContent = i;
        pageBtn.onclick = () => {
            currentTaskPage = i;
            renderTasksTable();
        };
        controls.appendChild(pageBtn);
    }
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.className = 'page-btn';
    nextBtn.textContent = 'Next';
    nextBtn.disabled = currentTaskPage === totalPages;
    nextBtn.onclick = () => {
        if (currentTaskPage < totalPages) {
            currentTaskPage++;
            renderTasksTable();
        }
    };
    controls.appendChild(nextBtn);
}

function updateMappingPagination() {
    const totalPages = Math.ceil(filteredMappings.length / CONFIG.maxRowsPerPage);
    const controls = document.getElementById('mappingPaginationControls');
    controls.innerHTML = '';
    
    if (totalPages <= 1) return;
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.className = 'page-btn';
    prevBtn.textContent = 'Previous';
    prevBtn.disabled = currentMappingPage === 1;
    prevBtn.onclick = () => {
        if (currentMappingPage > 1) {
            currentMappingPage--;
            renderMappingTable();
        }
    };
    controls.appendChild(prevBtn);
    
    // Page numbers
    for (let i = 1; i <= Math.min(totalPages, 5); i++) {
        const pageBtn = document.createElement('button');
        pageBtn.className = 'page-btn' + (i === currentMappingPage ? ' active' : '');
        pageBtn.textContent = i;
        pageBtn.onclick = () => {
            currentMappingPage = i;
            renderMappingTable();
        };
        controls.appendChild(pageBtn);
    }
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.className = 'page-btn';
    nextBtn.textContent = 'Next';
    nextBtn.disabled = currentMappingPage === totalPages;
    nextBtn.onclick = () => {
        if (currentMappingPage < totalPages) {
            currentMappingPage++;
            renderMappingTable();
        }
    };
    controls.appendChild(nextBtn);
}

function updateTaskPaginationInfo(from, to, total) {
    document.getElementById('taskShowingFrom').textContent = from;
    document.getElementById('taskShowingTo').textContent = to;
    document.getElementById('taskTotalRecords').textContent = total;
}

function updateMappingPaginationInfo(from, to, total) {
    document.getElementById('mappingShowingFrom').textContent = from;
    document.getElementById('mappingShowingTo').textContent = to;
    document.getElementById('mappingTotalRecords').textContent = total;
}

// Modal functions
function closeTaskModal() {
    document.getElementById('taskModal').classList.remove('active');
    document.getElementById('taskForm').reset();
}

function closeDeleteModal() {
    document.getElementById('deleteModal').classList.remove('active');
    taskToDelete = null;
}

// Refresh data
async function refreshTaskData() {
    await initializeApp();
    showToast('Data refreshed successfully', 'success');
}

// Utility functions
function showLoading(show, message = 'Loading...') {
    const overlay = document.getElementById('taskLoadingOverlay');
    if (overlay) {
        overlay.classList.toggle('active', show);
        if (message) {
            updateLoadingMessage(message);
        }
    }
}

function updateLoadingMessage(message) {
    const messageElement = document.getElementById('loadingMessage');
    if (messageElement) {
        messageElement.textContent = message;
    }
}

function showNoAccess() {
    document.getElementById('taskManagementPage').style.display = 'none';
    document.getElementById('taskNoAccessMessage').style.display = 'flex';
}

// Toast notification system
function showToast(message, type = 'info') {
    const toastContainer = document.getElementById('taskToastContainer');
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    const icons = {
        success: '<svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>',
        error: '<svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>',
        warning: '<svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>',
        info: '<svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>'
    };
    
    toast.innerHTML = `
        ${icons[type]}
        <span style="margin-left: 8px;">${message}</span>
    `;
    
    toastContainer.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('removing');
        setTimeout(() => {
            if (toast.parentElement) {
                toast.remove();
            }
        }, 300);
    }, 3000);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}