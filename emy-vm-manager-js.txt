// My VM Manager JavaScript with Libraries and Confluence REST API Integration

// Include required libraries (add these script tags to your Confluence page)
// <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
// <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
// <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

// Configuration
const CONFIG = {
    baseURL: 'www.myconfluence.net',
    attachmentPageId: '123345346',
    maxRowsPerPage: 50,
    files: {
        userDatabase: 'userdatabase.xlsx',
        mainTaskDatabase: 'maintaskdatabase.xlsx',
        taskMapping: 'taskmapping.xlsx',
        approvals: 'approvals.xlsx',
        notifications: 'notifications.xlsx'
    }
};

// Global variables
let currentUser = null;
let userSkills = [];
let taskMapping = [];
let notifications = [];
let currentPage = 1;
let filteredData = [];
let marketChart = null;

// Initialize the application
async function initializeApp() {
    showLoading(true);
    try {
        // Get current user from Confluence
        currentUser = await getCurrentUser();
        
        // Load all necessary data
        await loadUserData();
        await loadUserSkills();
        await loadTaskMapping();
        await loadNotifications();
        
        // Initialize UI components
        initializeUI();
        renderTable();
        updateStatistics();
        initializeChart();
        
    } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize application. Please refresh the page.');
    } finally {
        showLoading(false);
    }
}

// Get current user from Confluence REST API
async function getCurrentUser() {
    try {
        const response = await fetch(`/rest/api/user/current`, {
            headers: {
                'Accept': 'application/json'
            }
        });
        const data = await response.json();
        return {
            username: data.username || data.name,
            displayName: data.displayName,
            email: data.email
        };
    } catch (error) {
        console.error('Failed to get current user:', error);
        // Fallback for testing
        return { username: 'AM28890', displayName: 'Test User', email: 'test@example.com' };
    }
}

// Load user data from Excel
async function loadUserData() {
    try {
        const fileData = await fetchAttachment(CONFIG.files.userDatabase);
        const workbook = XLSX.read(fileData, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const users = XLSX.utils.sheet_to_json(worksheet);
        
        // Find current user in database
        const userData = users.find(u => u.username === currentUser.username);
        if (!userData) {
            throw new Error('User not found in database');
        }
        
        // Update user profile display
        document.getElementById('userName').textContent = userData.name;
        document.getElementById('userTeam').textContent = userData.team;
        document.getElementById('userRole').textContent = userData.role;
        document.getElementById('userTenure').textContent = userData.tenure;
        document.getElementById('userEmail').textContent = userData.email;
        
        // Store user data
        currentUser = { ...currentUser, ...userData };
        
    } catch (error) {
        console.error('Failed to load user data:', error);
        throw error;
    }
}

// Load user skills from Excel
async function loadUserSkills() {
    try {
        const fileData = await fetchAttachment(CONFIG.files.mainTaskDatabase);
        const workbook = XLSX.read(fileData, { type: 'array' });
        
        // Check if user has a sheet
        if (!workbook.SheetNames.includes(currentUser.username)) {
            showError('No skill data found for user');
            return;
        }
        
        const worksheet = workbook.Sheets[currentUser.username];
        userSkills = XLSX.utils.sheet_to_json(worksheet);
        filteredData = [...userSkills];
        
    } catch (error) {
        console.error('Failed to load user skills:', error);
        throw error;
    }
}

// Load task mapping from Excel
async function loadTaskMapping() {
    try {
        const fileData = await fetchAttachment(CONFIG.files.taskMapping);
        const workbook = XLSX.read(fileData, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        taskMapping = XLSX.utils.sheet_to_json(worksheet);
        
    } catch (error) {
        console.error('Failed to load task mapping:', error);
        throw error;
    }
}

// Load notifications from Excel
async function loadNotifications() {
    try {
        const fileData = await fetchAttachment(CONFIG.files.notifications);
        const workbook = XLSX.read(fileData, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const allNotifications = XLSX.utils.sheet_to_json(worksheet);
        
        // Filter notifications for current user
        notifications = allNotifications.filter(n => n.Username === currentUser.username);
        
        // Update notification badge
        const badge = document.getElementById('notificationBadge');
        badge.textContent = notifications.length;
        badge.style.display = notifications.length > 0 ? 'block' : 'none';
        
    } catch (error) {
        console.error('Failed to load notifications:', error);
    }
}

// Fetch attachment from Confluence
async function fetchAttachment(filename) {
    try {
        const response = await fetch(
            `/rest/api/content/${CONFIG.attachmentPageId}/child/attachment?filename=${filename}`,
            {
                headers: {
                    'Accept': 'application/json'
                }
            }
        );
        const data = await response.json();
        
        if (data.results && data.results.length > 0) {
            const attachment = data.results[0];
            const downloadUrl = `${attachment._links.download}`;
            
            const fileResponse = await fetch(downloadUrl);
            const arrayBuffer = await fileResponse.arrayBuffer();
            return new Uint8Array(arrayBuffer);
        }
        throw new Error(`Attachment ${filename} not found`);
        
    } catch (error) {
        console.error(`Failed to fetch ${filename}:`, error);
        // Return mock data for testing
        return new Uint8Array();
    }
}

// Initialize UI components
function initializeUI() {
    // Setup search
    document.getElementById('searchInput').addEventListener('input', handleSearch);
    
    // Setup filters
    setupFilters();
    
    // Setup export button
    document.getElementById('exportBtn').addEventListener('click', exportData);
    
    // Setup modal buttons
    document.getElementById('editSkillsBtn').addEventListener('click', openEditModal);
    document.getElementById('notificationBtn').addEventListener('click', openNotificationsModal);
}

// Setup filter dropdowns
function setupFilters() {
    const categories = [...new Set(userSkills.map(s => s.Category))];
    const taskGroups = [...new Set(userSkills.map(s => s.Task_Group))];
    
    const categoryFilter = document.getElementById('categoryFilter');
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat;
        categoryFilter.appendChild(option);
    });
    
    const taskGroupFilter = document.getElementById('taskGroupFilter');
    taskGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group;
        option.textContent = group;
        taskGroupFilter.appendChild(option);
    });
    
    categoryFilter.addEventListener('change', applyFilters);
    taskGroupFilter.addEventListener('change', applyFilters);
}

// Handle search
function handleSearch(e) {
    const searchTerm = e.target.value.toLowerCase();
    applyFilters();
}

// Apply all filters
function applyFilters() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const categoryFilter = document.getElementById('categoryFilter').value;
    const taskGroupFilter = document.getElementById('taskGroupFilter').value;
    
    filteredData = userSkills.filter(skill => {
        const matchesSearch = skill.Task_Name.toLowerCase().includes(searchTerm);
        const matchesCategory = !categoryFilter || skill.Category === categoryFilter;
        const matchesTaskGroup = !taskGroupFilter || skill.Task_Group === taskGroupFilter;
        
        return matchesSearch && matchesCategory && matchesTaskGroup;
    });
    
    currentPage = 1;
    renderTable();
}

// Render the skills table
function renderTable() {
    const tableHeader = document.getElementById('tableHeader');
    const tableBody = document.getElementById('tableBody');
    
    // Clear existing content
    tableHeader.innerHTML = '';
    tableBody.innerHTML = '';
    
    if (filteredData.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="100%" style="text-align: center; padding: 40px;">No data found</td></tr>';
        return;
    }
    
    // Get markets from first row
    const markets = Object.keys(filteredData[0]).filter(key => 
        !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
    );
    
    // Create header
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `
        <th>Item ID</th>
        <th>Category</th>
        <th>Task Group</th>
        <th>Task Name</th>
        ${markets.map(m => `<th class="market-header">${m}</th>`).join('')}
    `;
    tableHeader.appendChild(headerRow);
    
    // Calculate pagination
    const startIndex = (currentPage - 1) * CONFIG.maxRowsPerPage;
    const endIndex = Math.min(startIndex + CONFIG.maxRowsPerPage, filteredData.length);
    const pageData = filteredData.slice(startIndex, endIndex);
    
    // Create rows
    pageData.forEach(skill => {
        const row = document.createElement('tr');
        const mapping = taskMapping.find(t => t.Item_ID === skill.Item_ID);
        
        let rowHtml = `
            <td>${skill.Item_ID}</td>
            <td>${skill.Category}</td>
            <td>${skill.Task_Group}</td>
            <td>${skill.Task_Name}</td>
        `;
        
        markets.forEach(market => {
            const value = skill[market];
            const isApplicable = mapping && mapping[market] === 'x';
            
            if (!isApplicable) {
                rowHtml += `<td class="market-cell"><span class="skill-na">N/A</span></td>`;
            } else if (value === 'yes') {
                rowHtml += `<td class="market-cell"><span class="skill-yes">YES</span></td>`;
            } else {
                rowHtml += `<td class="market-cell"><span class="skill-no">NO</span></td>`;
            }
        });
        
        row.innerHTML = rowHtml;
        tableBody.appendChild(row);
    });
    
    // Update pagination
    updatePagination();
    
    // Update showing info
    document.getElementById('showingFrom').textContent = startIndex + 1;
    document.getElementById('showingTo').textContent = endIndex;
    document.getElementById('totalRecords').textContent = filteredData.length;
}

// Update pagination controls
function updatePagination() {
    const totalPages = Math.ceil(filteredData.length / CONFIG.maxRowsPerPage);
    const paginationControls = document.getElementById('paginationControls');
    paginationControls.innerHTML = '';
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.className = 'page-btn';
    prevBtn.textContent = 'Previous';
    prevBtn.disabled = currentPage === 1;
    prevBtn.onclick = () => {
        if (currentPage > 1) {
            currentPage--;
            renderTable();
        }
    };
    paginationControls.appendChild(prevBtn);
    
    // Page numbers
    let startPage = Math.max(1, currentPage - 2);
    let endPage = Math.min(totalPages, startPage + 4);
    
    if (endPage - startPage < 4) {
        startPage = Math.max(1, endPage - 4);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageBtn = document.createElement('button');
        pageBtn.className = 'page-btn' + (i === currentPage ? ' active' : '');
        pageBtn.textContent = i;
        pageBtn.onclick = () => {
            currentPage = i;
            renderTable();
        };
        paginationControls.appendChild(pageBtn);
    }
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.className = 'page-btn';
    nextBtn.textContent = 'Next';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.onclick = () => {
        if (currentPage < totalPages) {
            currentPage++;
            renderTable();
        }
    };
    paginationControls.appendChild(nextBtn);
}

// Update statistics
function updateStatistics() {
    const markets = Object.keys(userSkills[0] || {}).filter(key => 
        !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
    );
    
    let totalTasks = 0;
    let completedTasks = 0;
    const categoryStats = {};
    
    userSkills.forEach(skill => {
        if (!categoryStats[skill.Category]) {
            categoryStats[skill.Category] = { total: 0, completed: 0 };
        }
        
        markets.forEach(market => {
            const mapping = taskMapping.find(t => t.Item_ID === skill.Item_ID);
            if (mapping && mapping[market] === 'x') {
                totalTasks++;
                categoryStats[skill.Category].total++;
                
                if (skill[market] === 'yes') {
                    completedTasks++;
                    categoryStats[skill.Category].completed++;
                }
            }
        });
    });
    
    // Update task summary
    document.getElementById('completedTasks').textContent = completedTasks;
    document.getElementById('pendingTasks').textContent = totalTasks - completedTasks;
    document.getElementById('totalTasks').textContent = totalTasks;
    
    // Update progress bar
    const percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
    document.getElementById('progressFill').style.width = `${percentage}%`;
    document.getElementById('progressText').textContent = `${percentage}% Complete`;
    
    // Update category stats
    const categoryStatsDiv = document.getElementById('categoryStats');
    categoryStatsDiv.innerHTML = '';
    
    Object.entries(categoryStats).forEach(([category, stats]) => {
        const percentage = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
        const item = document.createElement('div');
        item.className = 'category-item';
        item.innerHTML = `
            <span class="category-name">${category}</span>
            <div class="category-progress">
                <div class="mini-progress">
                    <div class="mini-progress-fill" style="width: ${percentage}%"></div>
                </div>
                <span class="category-percentage">${percentage}%</span>
            </div>
        `;
        categoryStatsDiv.appendChild(item);
    });
}

// Initialize market coverage chart
function initializeChart() {
    const ctx = document.getElementById('marketChart').getContext('2d');
    const markets = Object.keys(userSkills[0] || {}).filter(key => 
        !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
    );
    
    const marketData = markets.map(market => {
        let total = 0;
        let completed = 0;
        
        userSkills.forEach(skill => {
            const mapping = taskMapping.find(t => t.Item_ID === skill.Item_ID);
            if (mapping && mapping[market] === 'x') {
                total++;
                if (skill[market] === 'yes') {
                    completed++;
                }
            }
        });
        
        return total > 0 ? Math.round((completed / total) * 100) : 0;
    });
    
    marketChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: markets,
            datasets: [{
                label: 'Coverage %',
                data: marketData,
                backgroundColor: 'rgba(48, 86, 211, 0.8)',
                borderColor: 'rgba(48, 86, 211, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100
                }
            },
            plugins: {
                legend: {
                    display: false
                }
            }
        }
    });
}

// Open edit skills modal
function openEditModal() {
    const modal = document.getElementById('editSkillsModal');
    const grid = document.getElementById('skillsEditGrid');
    grid.innerHTML = '';
    
    // Group skills by category
    const categories = {};
    userSkills.forEach(skill => {
        if (!categories[skill.Category]) {
            categories[skill.Category] = [];
        }
        categories[skill.Category].push(skill);
    });
    
    // Create skill edit interface
    Object.entries(categories).forEach(([category, skills]) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'skill-category';
        
        let categoryHtml = `<div class="skill-category-title">${category}</div>`;
        categoryHtml += '<div class="skill-tasks">';
        
        skills.forEach(skill => {
            const mapping = taskMapping.find(t => t.Item_ID === skill.Item_ID);
            const markets = Object.keys(skill).filter(key => 
                !['Item_ID', 'Category', 'Task_Group', 'Task_Name'].includes(key)
            );
            
            categoryHtml += `
                <div class="skill-task" data-item-id="${skill.Item_ID}">
                    <div class="task-name">${skill.Task_Name}</div>
                    <div class="market-checkboxes">
            `;
            
            markets.forEach(market => {
                const isApplicable = mapping && mapping[market] === 'x';
                const isChecked = skill[market] === 'yes';
                const disabled = !isApplicable ? 'disabled' : '';
                
                categoryHtml += `
                    <div class="market-checkbox ${disabled}">
                        <input type="checkbox" 
                               id="skill_${skill.Item_ID}_${market}" 
                               data-item-id="${skill.Item_ID}"
                               data-market="${market}"
                               ${isChecked ? 'checked' : ''} 
                               ${disabled}>
                        <label for="skill_${skill.Item_ID}_${market}">${market}</label>
                    </div>
                `;
            });
            
            categoryHtml += '</div></div>';
        });
        
        categoryHtml += '</div>';
        categoryDiv.innerHTML = categoryHtml;
        grid.appendChild(categoryDiv);
    });
    
    modal.classList.add('active');
}

// Close edit modal
function closeEditModal() {
    document.getElementById('editSkillsModal').classList.remove('active');
}

// Submit skill changes for approval
async function submitSkillChanges() {
    const changes = [];
    const checkboxes = document.querySelectorAll('#skillsEditGrid input[type="checkbox"]:not(:disabled)');
    
    checkboxes.forEach(checkbox => {
        const itemId = checkbox.dataset.itemId;
        const market = checkbox.dataset.market;
        const currentSkill = userSkills.find(s => s.Item_ID == itemId);
        
        if (currentSkill) {
            const currentValue = currentSkill[market] === 'yes';
            const newValue = checkbox.checked;
            
            if (currentValue !== newValue) {
                changes.push({
                    Item_ID: itemId,
                    Task_Name: currentSkill.Task_Name,
                    Category: currentSkill.Category,
                    Task_Group: currentSkill.Task_Group,
                    Market: market,
                    Old_Value: currentValue ? 'yes' : 'no',
                    New_Value: newValue ? 'yes' : 'no'
                });
            }
        }
    });
    
    if (changes.length === 0) {
        alert('No changes detected');
        return;
    }
    
    // Create approval request
    const requestId = Date.now();
    const approvalData = changes.map(change => ({
        'Request ID': requestId,
        'Username': currentUser.username,
        'Item_ID': change.Item_ID,
        'Category': change.Category,
        'Task_Group': change.Task_Group,
        'Task_Name': change.Task_Name,
        [change.Market]: change.New_Value,
        'Status': 'Pending',
        'Timestamp': new Date().toISOString()
    }));
    
    try {
        await updateApprovals(approvalData);
        alert(`Skill update request #${requestId} has been submitted for approval`);
        closeEditModal();
    } catch (error) {
        console.error('Failed to submit changes:', error);
        alert('Failed to submit changes. Please try again.');
    }
}

// Update approvals Excel file
async function updateApprovals(approvalData) {
    try {
        // Fetch current approvals
        const fileData = await fetchAttachment(CONFIG.files.approvals);
        const workbook = XLSX.read(fileData, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const currentApprovals = XLSX.utils.sheet_to_json(worksheet);
        
        // Add new approvals
        const updatedApprovals = [...currentApprovals, ...approvalData];
        
        // Create new worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(updatedApprovals);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Convert to binary and compress
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const compressed = pako.deflate(new Uint8Array(wbout));
        
        // Upload updated file
        await uploadAttachment(CONFIG.files.approvals, compressed);
        
    } catch (error) {
        console.error('Failed to update approvals:', error);
        throw error;
    }
}

// Upload attachment to Confluence
async function uploadAttachment(filename, data) {
    const formData = new FormData();
    formData.append('file', new Blob([data]), filename);
    formData.append('minorEdit', 'true');
    
    try {
        const response = await fetch(
            `/rest/api/content/${CONFIG.attachmentPageId}/child/attachment`,
            {
                method: 'POST',
                headers: {
                    'X-Atlassian-Token': 'nocheck'
                },
                body: formData
            }
        );
        
        if (!response.ok) {
            throw new Error('Upload failed');
        }
        
        return await response.json();
        
    } catch (error) {
        console.error(`Failed to upload ${filename}:`, error);
        throw error;
    }
}

// Open notifications modal
function openNotificationsModal() {
    const modal = document.getElementById('notificationsModal');
    const list = document.getElementById('notificationsList');
    list.innerHTML = '';
    
    if (notifications.length === 0) {
        list.innerHTML = '<p style="text-align: center; padding: 20px; color: #64748B;">No notifications</p>';
    } else {
        notifications.forEach(notification => {
            const item = document.createElement('div');
            item.className = `notification-item ${notification.Status.toLowerCase()}`;
            item.innerHTML = `
                <div class="notification-content">
                    <div class="notification-title">Request #${notification['Request ID']}</div>
                    <div class="notification-message">
                        Your ${notification['Request Type']} request has been ${notification.Status}
                    </div>
                    <div class="notification-time">${formatDate(notification.Timestamp)}</div>
                </div>
                <span class="notification-status ${notification.Status.toLowerCase()}">
                    ${notification.Status}
                </span>
            `;
            list.appendChild(item);
        });
    }
    
    modal.classList.add('active');
}

// Close notifications modal
function closeNotificationsModal() {
    document.getElementById('notificationsModal').classList.remove('active');
}

// Clear notifications
async function clearNotifications() {
    try {
        // Remove notifications for current user
        const fileData = await fetchAttachment(CONFIG.files.notifications);
        const workbook = XLSX.read(fileData, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const allNotifications = XLSX.utils.sheet_to_json(worksheet);
        
        // Filter out current user's notifications
        const updatedNotifications = allNotifications.filter(n => n.Username !== currentUser.username);
        
        // Update worksheet
        const newWorksheet = XLSX.utils.json_to_sheet(updatedNotifications);
        workbook.Sheets[workbook.SheetNames[0]] = newWorksheet;
        
        // Save and upload
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const compressed = pako.deflate(new Uint8Array(wbout));
        await uploadAttachment(CONFIG.files.notifications, compressed);
        
        // Clear local notifications
        notifications = [];
        document.getElementById('notificationBadge').style.display = 'none';
        closeNotificationsModal();
        
    } catch (error) {
        console.error('Failed to clear notifications:', error);
        alert('Failed to clear notifications');
    }
}

// Export data
function exportData() {
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(filteredData);
    XLSX.utils.book_append_sheet(wb, ws, 'My Skills');
    XLSX.writeFile(wb, `my_skills_${currentUser.username}_${Date.now()}.xlsx`);
}

// Utility functions
function formatDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
}

function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    overlay.classList.toggle('active', show);
}

function showError(message) {
    alert(message);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}